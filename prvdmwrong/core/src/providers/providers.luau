local types = require("@core/types")
local utils = require("@core/utils")

type ConstructedKey = types.ConstructedKey
type Provider<Self> = types.Provider<Self>
type LuauSolverIssue = any

-- Required so TypeScript class decorators can properly register providers
local CONSTRUCTED_KEY: ConstructedKey = newproxy();
(getmetatable(CONSTRUCTED_KEY :: any) :: any).__tostring = function()
	return "<Prvd 'M Wrong> CONSTRUCTED_KEY"
end

local constructedProviders = {}
local providerConstructed = {}

local providers = {}
providers.constructedKey = CONSTRUCTED_KEY
providers.constructedProviders = constructedProviders

--[=[
    @within Prvd
    @tag luau-only
    Construct and returns a new provider. Providers *provide* specific functionality in a game.

    Intended for use as a constructor for Luau projects. For Roblox TypeScript projects, consider using Provider instead.

    @param provider Self -- The provider and associated properties itself.
    @return Provider<Self> -- A newly constructed provider.
]=]
function providers.prvd<Self>(provider: Self, name: string?): Provider<Self>
	local newProvider: Provider<Self> = provider
	newProvider.name = newProvider.name or name

	for _, onProviderConstructed in providerConstructed do
		onProviderConstructed(newProvider)
	end

	newProvider[CONSTRUCTED_KEY] = newProvider
	constructedProviders[newProvider] = true
	return newProvider
end

--[=[
    @within Prvd
    @tag typescript-only
    Construct and returns a new provider from a Roblox TypeScript class declaration. Providers *provide* specific functionality in a game.

    Intended for use as a class decorator for Roblox TypeScript projects. For Luau projects, consider using prvd instead.

    @param provider Self & { new: (...unknown) -> unknown, constructor: (unknown, ...unknown) -> unknown } -- The provider class as generated by Roblox TypeScript.
    @return Provider<Self> -- A newly constructed provider.
]=]
function providers.Provider<Self>(provider: Self & {
	new: (...unknown) -> unknown,
	constructor: (unknown, ...unknown) -> unknown,
}): Provider<Self>
	-- HACK: this is all very janky and relies on the TypeScript compiler
	local newProvider = provider.new
	utils.assert(typeof(newProvider) == "function", "Missing `new`")
	utils.assert(typeof(provider.constructor) == "function", "Missing `constructor`")

	local providerMetatable = getmetatable(provider)
	utils.assert(typeof(providerMetatable) == "table", "")
	local providerToString = (providerMetatable :: any).__tostring
	utils.assert(typeof(providerToString) == "function", "")

	local constructedProvider: Provider<Self> = newProvider() :: any
	if not constructedProvider.name then
		constructedProvider.name = providerToString()
	end

	for _, onProviderConstructed in providerConstructed do
		onProviderConstructed(newProvider)
	end

	constructedProviders[constructedProvider] = true
	provider[CONSTRUCTED_KEY] = constructedProvider
	return constructedProvider
end

function providers.onProviderConstructed(listener: (provider: Provider<unknown>) -> ()): () -> ()
	local identifier = table.freeze({})
	providerConstructed[identifier] = listener

	return function()
		providerConstructed[identifier] = nil :: LuauSolverIssue
	end
end

return providers
