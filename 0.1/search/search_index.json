{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"LuauTypeScript <pre><code>local prvd = require(\"@pkg/ohmyprvd\")\nlocal CalculusProvider = require(\"./calculus-provider\")\n\nlocal MathProvider = {}\nMathProvider.calculusProvider = prvd.use(CalculusProvider)\n\nfunction MathProvider.add(self: typeof(MathProvider), a: number, b: number)\n  return self.calculusProvider.add(a, b)\nend\n\nreturn prvd.Provider(\"MathProvider\", MathProvider)\n</code></pre> <pre><code>import { Provider, use } from \"@rbxts/ohmyprvd\"\nimport CalculusProvider from \"./calculus-provider\"\n\nexport const MathProvider = Provider(\"MathProvider\", {\n  calculusProvider = use(CalculusProvider)\n\n  add(a: number, b: number) {\n    return this.CalculusProvider.add(a, b)\n  }\n})\nexport = MathProvider\n</code></pre>   Scroll down for a quick look at the three main highlights"},{"location":"#the-roblox-developerssecret-weapon","title":"The Roblox Developer'sSecret Weapon","text":"<p> Oh My Prvd is a delightful framework for next-generation Roblox game development. </p> <p> Oh My Prvd accelerates the process with providers, connecting the top-level design of your game. Choose to mix in networking and components as you need. Enjoy a development experience that fades into the background, freeing you to build faster and shout: </p> <p>\"Oh, My Prvd!\"</p> <p>Get Started \u00b7 Download \u00b7  Batteries included</p>"},{"location":"#providers","title":"Providers","text":"<p>Oh My Prvd introduces providers for your game logic. These provide specific functions within your game, e.g. you might create a <code>SaveDataProvider</code> to manage save files or a <code>CameraProvider</code> to handle player camera movement.</p> <p>Create providers to handle the top level logic of your game:</p> LuauTypeScript <pre><code>local CoinsProvider = {}\nreturn prvd.Provider(\"CoinsProvider\", CoinsProvider)\n</code></pre> <pre><code>export const CoinsProvider = prvd.Provider(\"CoinsProvider\", {\n})\n</code></pre> <p>At the end of the day, providers are just plain tables. It's easy to implement more methods, properties, and the likes into a provider:</p> LuauTypeScript <pre><code>local CoinsProvider = {}\nCoinsProvider.balance = {}\n\nfunction CoinsProvider.addCoins(\n  self: typeof(CoinsProvider),\n  player: Player,\n  coins: number\n)\n  self.coins[person] += coins\nend\n\nreturn prvd.Provider(\"CoinsProvider\", CoinsProvider)\n</code></pre> <pre><code>export const CoinsProvider = Provider(\"CoinsProvider\", {\n  balance: Map&lt;Player, number&gt; = {},\n\n  addCoins(\n    player: Player,\n    coins: number\n  ) {\n    this.coins[person] += coins\n  }\n})\n\nexport = CoinsProvider\n</code></pre> <p>Providers can <code>use()</code> other providers. Oh My Prvd will provide its types and figure out a corresponding load order for you:</p> LuauTypeScript <pre><code>local RewardsProvider = {}\nRewardsProvider.coinsProvider = prvd.use(CoinsProvider)\n\nfunction RewardsProvider.addWinRewards(\n  self: typeof(CoinsProvider),\n  player: Player,\n)\n  self.coinsProvider:addCoins(player, 30)\nend\n\nreturn prvd.Provider(\"RewardsProvider\", RewardsProvider)\n</code></pre> <pre><code>export const RewardsProvider = Provider(\"RewardsProvider\", {\n  coinsProvider = use(CoinsProvider)\n\n  addCoins(\n    person: Player\n  ) {\n    this.coinsProvider:addCoins(player, coins)\n  }\n})\n\nexport = RewardsProvider\n</code></pre> <p>Finally, preload your providers, then ignite Oh My Prvd, and you're off to the races:</p> <pre><code>prvd.loadDescendants(ServerScriptService.Providers)\nprvd.ignite()\n</code></pre>"},{"location":"#networking","title":"Networking","text":""},{"location":"#modding","title":"Modding","text":""},{"location":"api-reference/error-messages/","title":"Error Messages","text":"<p>Oh My Prvd attaches an error ID with every console log message. This is used to uniquely identify what kind of error or message you're seeing.</p> <p>For example, given the message below, the error ID would be <code>usedBeforeIgnition</code>.</p> <pre><code>[ohmyprvd error(usedBeforeIgnition)]: cannot use provider \"MyProvider\" prior to ignition\n</code></pre> <p>Use the search box below to paste in or type an error ID, and it will scroll to the details for you.</p> <p></p>"},{"location":"api-reference/error-messages/#alreadyignited","title":"alreadyIgnited","text":"<pre><code>cannot ignite more than once\n</code></pre> <p>Thrown by: <code>prvd.ignite</code></p> <p>You attempted to reignite Oh My Prvd when it has already been ignited.</p>"},{"location":"api-reference/error-messages/#cannotregister","title":"cannotRegister","text":"<pre><code>cannot register provider; `MyProvider.init` should be a function\n</code></pre> <p>Thrown by: <code>prvd.Provider</code>, <code>prvd.new</code></p> <p>You attempted to register a new provider, but Oh My Prvd caught something wrong. The error includes a more specific message which can be used to diagnose the issue. Typically it is one of the following:</p> <ul> <li>A provider of the same name was already registered</li> <li>You have frozen the provider table, which prevents dependency injection</li> <li>You provided a mismatched type for a built-in method/property</li> <li>You forgot to include a non-empty string as a <code>name</code></li> </ul>"},{"location":"api-reference/error-messages/#cannotusenonprovider","title":"cannotUseNonProvider","text":"<pre><code>`use()` must be given a provider\n</code></pre> <p>Thrown by: <code>prvd.use</code></p> <p>You attempted to <code>use()</code> an object that was not registered as a provider.</p>"},{"location":"api-reference/error-messages/#initerror","title":"initError","text":"<p>Thrown by: <code>prvd.ignite</code></p> <pre><code>cannot initialize MyProvider; attempted to index nil with 'property'\n</code></pre> <p>Oh My Prvd could not finish its initialization lifecycle as a provider threw an error in it's <code>:init</code> method. The error includes a more specific message which can be used to diagnose the issue.</p>"},{"location":"api-reference/error-messages/#invalidloadparent","title":"invalidLoadParent","text":"<p>Thrown by: <code>prvd.loadChildren</code>, <code>prvd.loadDescendants</code></p> <pre><code>loadX must be given an instance\n</code></pre> <p><code>loadChildren</code> and <code>loadDescendants</code> expected you to give it a parent instance to load from, but you gave it something else.</p>"},{"location":"api-reference/error-messages/#invalidonignitioncallback","title":"invalidOnIgnitionCallback","text":"<pre><code>`onIgnition` must be given callbacks\n</code></pre> <p>Thrown by: <code>prvd.onIgnition</code></p> <p><code>onIgnition</code> expected you to give it a callback to spawn after ignition finishes, but you gave it something else.</p>"},{"location":"api-reference/error-messages/#registerafterignition","title":"registerAfterIgnition","text":"<pre><code>cannot register providers after ignition\n</code></pre> <p>Thrown by: <code>prvd.Provider</code>, <code>prvd.new</code></p> <p>You attempted to register a provider after ignition.</p> <p>Make sure you've preloaded all providers you will use prior to ignition, and that no other module registers a provider after ignition.</p>"},{"location":"api-reference/error-messages/#requireerror","title":"requireError","text":"<pre><code>cannot require ServerScriptService.Providers.MyProvider; Module code did not return exactly one value\n</code></pre> <p>Thrown by: <code>prvd.loadChildren</code>, <code>prvd.loadDescendants</code></p> <p><code>loadChildren</code> and <code>loadDescendants</code> loaded a module which threw an error that Oh My Prvd cannot handle. The error includes a more specific message which can be used to diagnose the issue.</p>"},{"location":"api-reference/error-messages/#serverrenderlifecycle","title":"serverRenderLifecycle","text":"<pre><code>cannot use `:render` lifecycle from the server\n</code></pre> <p>Thrown by: <code>prvd.Provider</code>, <code>prvd.new</code></p> <p>You included a <code>:render</code> lifecycle method in one of your providers on the server. This is undesirable as the server cannot access <code>RunService.RenderStepped</code>.</p>"},{"location":"api-reference/error-messages/#unknown","title":"unknown","text":"<pre><code>unknown error: attempt to call a nil value\nhelp: this indicates oh my prvd isn't reporting errors correctly, please file an issue\n</code></pre> <p>Oh My Prvd ran into an error, but cannot associate it with an error message. This is a fallback error type which shouldn't be seen by end users, because it indicates that Oh My Prvd is not reporting errors correctly.</p> Note on Oh My Prvd's alpha release <p>Oh My Prvd may have reported an error message that has not been registered yet. If the message just uses <code>camelCase</code> and reads as a lint error, it's a missing error message and should be reported as an issue.</p>"},{"location":"api-reference/error-messages/#useafterignition","title":"useAfterIgnition","text":"<pre><code>cannot use other providers after ignition\n</code></pre> <p>Thrown by: <code>prvd.use</code></p> <p>You tried to <code>use()</code> another provider after ignition started.</p> <p>Make sure every provider explicitly <code>use()</code>s all providers it needs. This lets Oh My Prvd figure out a corresponding load order.</p>"},{"location":"api-reference/error-messages/#usedbeforeignition","title":"usedBeforeIgnition","text":"<pre><code>cannot use provider \"MyProvider\" prior to ignition\nhelp: ohmyprvd will inject the dependency for you during runtime, its safe to use the provider inside a lifecycle method\n</code></pre> <p>You tried to access the contents of a <code>use()</code>d provider prior to ignition.</p> <p>Oh My Prvd will inject the dependency for you when ignited and figure out a corresponding load order. Make sure when you use another provider, you're using it from a lifecycle method.</p>"},{"location":"api-reference/core/members/await-ignition/","title":"awaitIgnition","text":"<p>Yields the calling thread just before ignition finishes. If Oh My Prvd has already started, the thread will continue.</p> LuauTypeScript <pre><code>function prvd.awaitIgnition(): ()\n</code></pre> <pre><code>export const awaitIgnition: () =&gt; void\n</code></pre>"},{"location":"api-reference/core/members/await-ignition/#learn-more","title":"Learn More","text":"<ul> <li>Ignition tutorial</li> </ul>"},{"location":"api-reference/core/members/ignite/","title":"ignite","text":"<p>Ignites Oh My Prvd. Expected to be called once in an environment, e.g. once on the server and once on the client.</p> <p>All necessary providers should be preloaded before calling this as newly created providers will not run its lifecycle events.</p> LuauTypeScript <pre><code>function prvd.ignite(\n  options: {\n    logLevel: \"none\" | \"verbose\" | nil,\n    profiling: boolean?,\n  }?\n): ()\n</code></pre> <pre><code>export const ignite: (\n  options: Partial&lt;Options&gt; = {\n    logLevel: \"none\",\n    profiling: RunService.IsStudio(),\n  }\n) =&gt; void\n</code></pre>"},{"location":"api-reference/core/members/ignite/#parameters","title":"Parameters","text":""},{"location":"api-reference/core/members/ignite/#options-partialoptions","title":"options <code>: Partial&lt;Options&gt;</code>","text":"<p>Configures how Oh My Prvd will ignite. The following are the available configuration options:</p> <ul> <li><code>logLevel: \"none\" | \"verbose\"</code> configures if Oh My Prvd should log trace   information to the console, defaults to none.</li> <li><code>profiling: boolean</code> configures if built-in lifecycle events should be   profiled with <code>debug.setmemorycategory</code> and <code>debug.profilebegin</code>, defaults to   whether the current session is running in Roblox Studio.</li> </ul>"},{"location":"api-reference/core/members/ignite/#learn-more","title":"Learn More","text":"<ul> <li>Ignition tutorial</li> </ul>"},{"location":"api-reference/core/members/ignition-status/","title":"IgnitionStatus","text":"<p>An enumeration of all defined ignition status Oh My Prvd will be in.</p> <p>This enum is not useful outside of Oh My Prvd itself; prefer to work with <code>awaitIgnition()</code> and <code>onIgnition(callback)</code></p> LuauTypeScript <pre><code>prvd.IgnitionStatus = {\n  Pending = \"IgnitionStatus.Pending\",\n  Ignition = \"IgnitionStatus.Ignition\",\n  Ignited = \"IgnitionStatus.Ignited\"\n}\n</code></pre> <pre><code>export enum IgnitionStatus {\n  Pending = \"IgnitionStatus.Pending\",\n  Ignition = \"IgnitionStatus.Ignition\",\n  Ignited = \"IgnitionStatus.Ignited\"\n}\n</code></pre>"},{"location":"api-reference/core/members/ignition-status/#items","title":"Items","text":""},{"location":"api-reference/core/members/ignition-status/#pending-ignitionstatuspending","title":"Pending <code>: IgnitionStatus.Pending</code>","text":"<p>Indicates that <code>prvd.ignite()</code> has not been called yet. Calls to <code>prvd.use()</code> and <code>prvd.Provider()</code> are safe.</p>"},{"location":"api-reference/core/members/ignition-status/#ignition-ignitionstatusignition","title":"Ignition <code>: IgnitionStatus.Ignition</code>","text":"<p>Indicates that <code>prvd.ignite()</code> has been called, but the ignition process has not finished. Calls to <code>prvd.use()</code> and <code>prvd.Provider()</code> will throw an error.</p>"},{"location":"api-reference/core/members/ignition-status/#ignited-ignitionstatusignited","title":"Ignited <code>: IgnitionStatus.Ignited</code>","text":"<p>Indicates that the ignition process has finished. Calls to <code>prvd.use()</code> and <code>prvd.Provider()</code> will throw an error.</p> <p>Awaiting threads from <code>prvd.awaitIgnition()</code> and queued callbacks from <code>prvd.onIgnition()</code> will be spawned just before the ignition status is set to this.</p>"},{"location":"api-reference/core/members/implement-method/","title":"implementMethod","text":"<p>Listen for when a provider implements a lifecycle method. Commonly used to implement custom lifecycles by adding providers to a \"watchlist\" which will have its methods fired.</p> LuauTypeScript <pre><code>function prvd.implementMethod(\n  method: string,\n  handler: (Provider&lt;unknown&gt;) -&gt; ()\n): ()\n</code></pre> <pre><code>export const implementMethod: (\n  method: string,\n  handler: (Provider&lt;unknown&gt;) =&gt; void\n) =&gt; void\n</code></pre>"},{"location":"api-reference/core/members/implement-method/#parameters","title":"Parameters","text":""},{"location":"api-reference/core/members/implement-method/#method-string","title":"method <code>: string</code>","text":"<p>The method to implement. During ignition, all providers that specify this method will have its handler be called.</p>"},{"location":"api-reference/core/members/implement-method/#handler-providerunknown-void","title":"handler <code>: (Provider&lt;unknown&gt;) -&gt; void</code>","text":"<p>A handler for providers that implement the specified methods. It receives the provider which implements the method. Commonly used to implement custom lifecycles by adding providers to a \"watchlist\" which will have its methods fired.</p>"},{"location":"api-reference/core/members/load-children/","title":"loadChildren","text":"<p>Preload the specified parent by requiring all <code>ModuleScripts</code> within it. An optional <code>predicate</code> function can be provided to filter modules.</p> LuauTypeScript <pre><code>function prvd.loadChildren(\n  parent: Instance,\n  predicate: ((ModuleScript) -&gt; boolean)?\n): { unknown }\n</code></pre> <pre><code>export const loadChildren: (\n  parent: Instance,\n  predicate?: (module: ModuleScript) =&gt; boolean\n) =&gt; unknown[]\n</code></pre>"},{"location":"api-reference/core/members/load-children/#parameters","title":"Parameters","text":""},{"location":"api-reference/core/members/load-children/#parent-instance","title":"parent <code>: Instance</code>","text":"<p>The parent to load ModuleScripts from. Internally uses <code>:GetChildren()</code> to load modules.</p>"},{"location":"api-reference/core/members/load-children/#predicate-modulescript-boolean","title":"predicate <code>: (ModuleScript) -&gt; boolean</code>","text":"<p>An optional predicate function that will be called to filter the modules to load with.</p>"},{"location":"api-reference/core/members/load-children/#learn-more","title":"Learn More","text":"<ul> <li>Ignition tutorial</li> </ul>"},{"location":"api-reference/core/members/load-descendants/","title":"loadDescendants","text":"<p>Preload the specified parent by requiring all <code>ModuleScripts</code> within it recursively. An optional <code>predicate</code> function can be provided to filter modules.</p> LuauTypeScript <pre><code>function prvd.loadDescendants(\n  parent: Instance,\n  predicate: ((ModuleScript) -&gt; boolean)?\n): { unknown }\n</code></pre> <pre><code>export const loadDescendants: (\n  parent: Instance,\n  predicate?: (module: ModuleScript) =&gt; boolean\n) =&gt; unknown[]\n</code></pre>"},{"location":"api-reference/core/members/load-descendants/#parameters","title":"Parameters","text":""},{"location":"api-reference/core/members/load-descendants/#parent-instance","title":"parent <code>: Instance</code>","text":"<p>The parent to load ModuleScripts from. Internally uses <code>:GetDescendants()</code> to load modules.</p>"},{"location":"api-reference/core/members/load-descendants/#predicate-modulescript-boolean","title":"predicate <code>: (ModuleScript) -&gt; boolean</code>","text":"<p>An optional predicate function that will be called to filter the modules to load with.</p>"},{"location":"api-reference/core/members/load-descendants/#learn-more","title":"Learn More","text":"<ul> <li>Ignition tutorial</li> </ul>"},{"location":"api-reference/core/members/on-ignition/","title":"onIgnition","text":"<p>Queues a callback to be called just before ignition finishes. If Oh My Prvd has already started, the callback will be spawned immediately.</p> LuauTypeScript <pre><code>function prvd.onIgnition(\n  callback: () -&gt; ()\n): ()\n</code></pre> <pre><code>export const onIgnition: (\n  callback: () =&gt; void\n) =&gt; void\n</code></pre>"},{"location":"api-reference/core/members/on-ignition/#parameters","title":"Parameters","text":""},{"location":"api-reference/core/members/on-ignition/#callback-","title":"callback <code>: () -&gt; ()</code>","text":"<p>The callback to be spawned just before ignition finishes.</p>"},{"location":"api-reference/core/members/on-ignition/#learn-more","title":"Learn More","text":"<ul> <li>Ignition tutorial</li> </ul>"},{"location":"api-reference/core/members/provider/","title":"Provider","text":"<p>Constructs and returns a new provider within Oh My Prvd. Providers must be created before calling <code>Prvd.ignite()</code>.</p> LuauTypeScript <pre><code>function prvd.Provider&lt;T&gt;(\n  name: string,\n  provider: T\n): Provider&lt;T&gt;\n</code></pre> Too verbose? <p>If writing <code>prvd.Provider</code> sounds verbose for you, Oh My Prvd aliases the <code>Provider</code> constructor with <code>new</code>:</p> <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nreturn prvd.new(\"PointsProvider\", PointsProvider)\n</code></pre> <p>For consistency, we recommend using <code>Provider</code> when favorable, as <code>new</code> is a reserved keyword in TypeScript.</p> <pre><code>export const Provider: &lt;T extends object&gt;(\n  name: string,\n  provider: T\n) =&gt; Provider&lt;T&gt;\n</code></pre>"},{"location":"api-reference/core/members/provider/#parameters","title":"Parameters","text":""},{"location":"api-reference/core/members/provider/#name-string","title":"name <code>: string</code>","text":"<p>A unique name to identify the provider with. This will be used for debugging.</p>"},{"location":"api-reference/core/members/provider/#provider-t","title":"provider <code>: T</code>","text":"<p>The methods and properties of the provider. Oh My Prvd provides a handful of lifecycle methods which may be specified:</p> <ul> <li><code>:init</code> runs sequentially before any other lifecycle methods, methods are   expected to be infallible and preferably non-yielding.</li> <li><code>:start</code> runs concurrently after all other lifecycle methods have been   registered. This means failures and yields do not affect other providers.</li> <li><code>:heartbeat</code> is ran every <code>RunService.Heartbeat</code> and is optimal for responding   to changes in the physics state.</li> <li><code>:step</code> is ran every <code>RunService.Stepped</code> and is optimal for manipulating   physics.</li> <li><code>:render</code> is ran every <code>RunService.RenderStepped</code>. Notably, this lifecycle   event only runs on the client.</li> </ul> <p>In addition, the provider may also specify a <code>loadOrder</code> property which dictates when the provider is loaded, defaults to <code>1</code>.</p>"},{"location":"api-reference/core/members/provider/#returns-providert","title":"Returns <code>: Provider&lt;T&gt;</code>","text":"<p>A freshly registered provider.</p>"},{"location":"api-reference/core/members/provider/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"api-reference/core/members/use/","title":"use","text":"<p>Uses a provider within Oh My Prvd. During ignition, Oh My Prvd will inject the dependencies your provider uses.</p> LuauTypeScript <pre><code>function prvd.use&lt;T&gt;(\n  provider: Provider&lt;T&gt;\n): T\n</code></pre> <pre><code>export const use: &lt;T extends object&gt;(\n  provider: Provider&lt;T&gt;\n) =&gt; T\n</code></pre> <p>Do not use dependencies outside of lifecycle methods</p> <p>Oh My Prvd only returns a shadow of the <code>use()</code>d provider. You cannot use it outside of lifecycle methods</p> <p>Behind the scenes, Oh My Prvd will keep track of what dependencies your provider uses, figure out the correct load order for you, and inject your dependencies.</p> <p>This is also why you can't freeze your provider tables - this prevents Oh My Prvd from modifying them, thus preventing dependency injection.</p>"},{"location":"api-reference/core/members/use/#parameters","title":"Parameters","text":""},{"location":"api-reference/core/members/use/#provider-providert","title":"provider <code>: Provider&lt;T&gt;</code>","text":"<p>The provider to use.</p>"},{"location":"api-reference/core/members/use/#returns-t","title":"Returns <code>: T</code>","text":"<p>The used provider. In reality, this returns a shadow of the provider, which will be injected during ignition.</p>"},{"location":"api-reference/core/members/use/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"api-reference/core/types/options/","title":"Options","text":"<p>Configures how Oh My Prvd will ignite. The following are the available configuration options: This type is not useful outside of Oh My Prvd itself; prefer to specify ignition options as a parameter of <code>ignite(options)</code></p> LuauTypeScript <pre><code>export type Options = {\n  logLevel: \"none\" | \"verbose\",\n  profiling: boolean\n}\n</code></pre> <pre><code>export type Options = {\n  logLevel: \"none\" | \"verbose\"\n  profiling: boolean\n}\n</code></pre>"},{"location":"api-reference/core/types/options/#members","title":"Members","text":""},{"location":"api-reference/core/types/options/#loglevel-none-verbose","title":"logLevel <code>: \"none\" | \"verbose\"</code>","text":"<p>Configures if Oh My Prvd should log trace information to the console, defaults to <code>\"none\"</code>.</p>"},{"location":"api-reference/core/types/options/#profiling-boolean","title":"profiling <code>: boolean</code>","text":"<p>Configures if built-in lifecycle events should be profiled with <code>debug.setmemorycategory</code> and <code>debug.profilebegin</code>, defaults to whether the current session is running in Roblox Studio.</p>"},{"location":"api-reference/core/types/options/#learn-more","title":"Learn More","text":"<ul> <li>Ignition tutorial</li> </ul>"},{"location":"api-reference/core/types/provider/","title":"Provider","text":"<p>Provides a specific functionality for a game. This type is not useful outside of Oh My Prvd itself; prefer to use <code>use(provider)</code> for more precise types.</p> LuauTypeScript <pre><code>export type Provider&lt;T&gt; = T &amp; {\n  loadOrder: number?,\n\n  init: ((self: Provider&lt;T&gt;) -&gt; Promise?)?,\n  start: (self: Provider&lt;T&gt;) -&gt; ()?,\n  heartbeat: (self: Provider&lt;T&gt;, dt: number) -&gt; ()?,\n  step: (self: Provider&lt;T&gt;, dt: number) -&gt; ()?,\n  render: (self: Provider&lt;T&gt;, dt: number) -&gt; ()?,\n}\n</code></pre> <pre><code>export type Provider&lt;T extends object&gt; = T &amp; {\n  loadOrder?: number,\n\n  init?(): void | Promise&lt;void&gt;,\n  start?(): void,\n  heartbeat?(dt: number): void,\n  step?(dt: number): void,\n  render?(dt: number): void,\n}\n</code></pre>"},{"location":"api-reference/core/types/provider/#members","title":"Members","text":""},{"location":"api-reference/core/types/provider/#loadorder-number","title":"loadOrder <code>: number</code>","text":"<p>Determines when to initialize the provider. Defaults to <code>1</code>. This member is not generally useful, as Oh My Prvd will figure out a load order with dependency injection.</p>"},{"location":"api-reference/core/types/provider/#init-self-providert-promise","title":"init <code>: (self: Provider&lt;T&gt;) -&gt; Promise?</code>","text":"<p>Runs sequentially before any other lifecycle methods, methods are expected to be infallible and preferably non-yielding.</p> <p>If it returns a promise, Oh My Prvd will await for the promise to resolve.</p>"},{"location":"api-reference/core/types/provider/#start-self-providert-","title":"start <code>: (self: Provider&lt;T&gt;) -&gt; ()</code>","text":"<p>Runs concurrently after all other lifecycle methods have been registered. This means failures and yields do not affect other providers.</p>"},{"location":"api-reference/core/types/provider/#heartbeat-self-providert-dt-number-","title":"heartbeat: <code>: (self: Provider&lt;T&gt;, dt: number) -&gt; ()</code>","text":"<p>Runs every <code>RunService.Heartbeat</code> and is optimal for responding to changes in the physics state.</p>"},{"location":"api-reference/core/types/provider/#step-self-providert-dt-number-","title":"step: <code>: (self: Provider&lt;T&gt;, dt: number) -&gt; ()</code>","text":"<p>Runs every <code>RunService.Stepped</code> and is optimal for manipulating physics.</p>"},{"location":"api-reference/core/types/provider/#render-self-providert-dt-number-","title":"render: <code>: (self: Provider&lt;T&gt;, dt: number) -&gt; ()</code>","text":"<p>Runs every <code>RunService.RenderStepped</code>. Notably, this lifecycle event only runs on the client.</p>"},{"location":"api-reference/core/types/provider/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"tutorials/","title":"Get Started","text":"<p>Congratulations on choosing Oh My Prvd! You're already making good choices.</p> <p>Oh My Prvd is a delightful framework for next-generation Roblox game development. Here, you will learn how to build great games with Oh My Prvd, even if you're a complete newcomer to the library.</p> <p>But first, something important...</p> <p> Do not use Oh My Prvd in production unless you're really, really, really, REALLY, really willing and able to withstand large, sweeping changes. </p> <p>Yes, that was five-reallys important.</p> <p>Oh My Prvd is in very early alpha right now! You will encounter:</p> <ul> <li>nonexistent or broken features</li> <li>changes in how things work between versions</li> <li>updates that completely remove existing features</li> <li>evolving recommendations on conventions and project structure</li> </ul> <p>This is not a bad thing! It means we can quickly abandon counterproductive ideas and features, and build a solid foundation for the future.</p> <p>Don't be discouraged though, feel free to follow along with our development and try using the library in your own time. We hope you enjoy using Oh My Prvd!</p>"},{"location":"tutorials/#expectations","title":"Expectations","text":"<p>These tutorials assume:</p> <ul> <li>That you're comfortable with Roblox and the Luau scripting language.<ul> <li>These tutorials are not an introduction Luau \u2013 If you'd like to learn,     see the Roblox creator documentation.</li> </ul> </li> <li>That - if you're using Roblox TypeScript - you're comfortable with TypeScript.<ul> <li>These tutorials are not an introduction to TypeScript - If you'd like     to learn, see Roblox TypeScript's documentation     and the TypeScript handbook</li> <li>These tutorials also assume you're familiar with Luau, which especially     is important when troubleshooting bugs \u2013 If you'd like to learn, see the     Roblox creator documentation.</li> </ul> </li> </ul> <p>Some tutorials might challenge you more than others. Remember, Oh My Prvd is built with you in mind, but it may still take a bit of time to absorb some concepts. Take your time and explore at your own pace.</p>"},{"location":"tutorials/#support","title":"Support","text":"<p>Should you be struggling to understand a concept, or need help debugging an error, here are some resources which can help.</p>"},{"location":"tutorials/#support-with-errors","title":"Support with Errors","text":"<p>Oh My Prvd attaches a link with every console log message. These links direct you to our comprehensive Error Messages documentation.</p> <pre><code>[ohmyprvd error(requireAfterIgnition)]: cannot require other providers after ignition\n  more info: team-fireworks.github.io/ohmyprvd/latest/api-reference/general/error-messages#requireafterignition\n  stack trace:\n    ohmyprvd.log:118 function throw\n    ohmyprvd.prvd:181 function use\n    Main:42\n</code></pre> <p>It explains the meaning of each message, its origin within Oh My Prvd, and relevant context. When you run into an error, that page is a great place to start!</p>"},{"location":"tutorials/#additional-support","title":"Additional Support","text":"<p>Oh My Prvd is built with you in mind and our documentation aims to be as useful and comprehensive as possible. However, you might need specific advice on an issue, perhaps you may want to learn Oh My Prvd through other means, or you caught a showstopper bug.</p> <p>Whatever you're looking for, feel free to swing by our dedicated thread over the Roblox OSS Discord server. Maintainers drop in frequently alongside eager Oh My Prvd users.</p>"},{"location":"tutorials/ignition/","title":"Ignition","text":"<p>With your providers defined, its time to ignite Oh My Prvd.</p>"},{"location":"tutorials/ignition/#preloading","title":"Preloading","text":"<p>It's necessary to preload your providers to for Oh My Prvd to pick it up. For convenience, you can use either <code>loadChildren()</code> or the <code>loadDescendants()</code> function, which will load all providers from a parent's children or descendants respectively:</p> LuauTypeScript <pre><code>local prvd = require(\"@pkg/ohmyprvd\")\nprvd.loadChildren(script.Providers)\nprvd.loadDescendants(script.Providers)\n</code></pre> <pre><code>import { loadChildren, loadDescendants } from \"@rbxts/ohmyprvd\"\nloadChildren(script.Providers)\nloadDescendants(script.Providers)\n</code></pre> <p>You can also pass a predicate function to filter the target modules:</p> LuauTypeScript <pre><code>local prvd = require(\"@pkg/ohmyprvd\")\nprvd.loadDescendants(\n  script.Providers,\n  function(module: ModuleScript)\n    return module.Name:find(\"Provider$\") ~= nil\n  end\n)\n</code></pre> <pre><code>import { LoadMode, loadDescendants } from \"@rbxts/ohmyprvd\"\nloadDescendants(\n  script.Providers,\n  (module) =&gt; module.Name.find(\"Provider$\") !== undefined\n)\n</code></pre>"},{"location":"tutorials/ignition/#ignite","title":"Ignite","text":"<p>Finally, ignite Oh My Prvd, and you're off to the races:</p> <pre><code>prvd.ignite()\n</code></pre> <p>If another script requires Oh My Prvd to be ignited, <code>awaitIgnition()</code> can be used, which will yield until Oh My Prvd is fully ignited:</p> <pre><code>prvd.awaitIgnition()\n</code></pre> <p>Alternatively, if you need to bind to ignition, <code>onIgnition(callback)</code> can be used, which will spawn the callback when Oh My Prvd has fully ignited:</p> LuauTypeScript <pre><code>prvd.onIgnition(function()\n  print(\"ignited!\")\nend)\n</code></pre> <pre><code>prvd.onIgnition(() =&gt; print(\"ignited!\"))\n</code></pre>"},{"location":"tutorials/installation/","title":"Installation","text":"<p>Oh My Prvd is distributed as a single module script, which you will need to import into your game.</p>"},{"location":"tutorials/installation/#methods","title":"Methods","text":""},{"location":"tutorials/installation/#install-via-roblox","title":"Install via Roblox","text":"<p>If you edit directly inside Roblox Studio, then you can import a Roblox model file containing Og My Prvd.</p> <ol> <li>Click the 'Assets' dropdown to view the downloadable files</li> <li>Click on the package you would like to import, which should end in <code>.rbxm</code>.   If you are just following the tutorials, just <code>ohmyprvd.rbxm</code> will do.</li> <li>Open Roblox Studio to import the model. If you are just following the   tutorials, just an empty baseplate will do.</li> <li>Right-click on <code>ReplicatedStorage</code>, and select 'Insert from File'</li> <li>You should see an <code>ohmyprvd</code> module script appear in ReplicatedStorage!</li> </ol>"},{"location":"tutorials/installation/#install-via-a-package-manager","title":"Install via a Package Manager","text":"<p>If you use Wally for Luau or NPM for TypeScript, Oh My Prvd has packages for both package managers.</p> WallyNPM &amp; PNPM <p>Append this below <code>[dependencies]</code> in your <code>wally.toml</code>:</p> <pre><code>ohmyprvd = \"znotfireman/ohmyprvd\"\n</code></pre> <p>Then, install your packages:</p> <pre><code>$ wally install\n</code></pre> <p>This will install Oh My Prvd into the\u00a0<code>Packages</code>\u00a0directory, though the actual location of the folder in-game depends on your Rojo project configuration, but it is usually in\u00a0<code>ReplicatedStorage</code>.</p> <p>Run either of these commands:</p> <pre><code>$ npm i @rbxts/ohmyprvd # npm\n$ pnpm i @rbxts/ohmyprvd # pnpm\n</code></pre> <p>This will install Oh My Prvd under <code>node_modules</code>, which can be imported directly:</p> <pre><code>import ohmyprvd from \"@rbxts/znotfireman\"\n</code></pre>"},{"location":"tutorials/installation/#install-via-source","title":"Install via Source","text":"<p>If you are synchronizing external files into Roblox Studio, Oh My Prvd can be imported as source code.</p> <ol> <li>Click the 'Assets' dropdown to view the downloadable files</li> <li>Under 'Assets', download <code>Source code (zip)</code>. Inside is a copy of the Oh My   Prvd GitHub repository.</li> <li>Inside the zip, open <code>packages</code>, then the package you'd like to import,   and copy it's <code>out</code> folder; it may be inside another folder.</li> <li>Create a new folder inside your project named \"ohmyprvd\", place it wherever   you keep your libraries.</li> <li>For example, you might paste it inside a\u00a0<code>shared</code>\u00a0or\u00a0a <code>packages</code>\u00a0folder.</li> <li>Paste the contents of the <code>out</code> folder into the newly created folder.</li> </ol>"},{"location":"tutorials/installation/#testing","title":"Testing","text":"<p>Now, you can create a script for testing:</p> <ol> <li>Create a <code>Script</code> under <code>ServerScriptService</code>.</li> <li> <p>Remove the following code, and paste this in depending on your installation:</p> RobloxWallyTypeScriptDarklua <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.ohmyprvd)\n</code></pre> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n</code></pre> <pre><code>import ohmyprvd from \"@rbxts/ohmyprvd\"\n</code></pre> <pre><code>local prvd = require(\"@pkg/ohmyprvd\")\n</code></pre> </li> <li> <p>Press 'Play' - if there are no errors, everything was set up correctly!</p> </li> </ol> My script didn't work! <p><pre><code>ohmyprvd is not a valid member of ReplicatedStorage \"ReplicatedStorage\"\n</code></pre> If you're seeing this error, then your script can't find Oh My Prvd.</p> <p>This code assumes you've placed Oh My Prvd under ReplicatedStorage. If you've installed both elsewhere, you'll need to the <code>require()</code>\u00a0to point towards the correct location.</p> <p>If both looks like it points to the correct location, refer back to\u00a0the previous section\u00a0and double-check you've set everything up properly. Make sure under ReplicatedStorage, there's a ModuleScript named <code>ohmyprvd</code>.</p>"},{"location":"tutorials/providers/","title":"Providers","text":"<p>Oh My Prvd allows you to define providers for your game logic. These provide specific functions within your game, e.g. you might create a <code>SaveDataProvider</code> to manage save files or a <code>CameraProvider</code> to handle player camera movement.</p>"},{"location":"tutorials/providers/#structure","title":"Structure","text":"<p>This is the minimum structure of a provider, which can be used and hook onto lifecycle events:</p> LuauTypeScript <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\n\nexport = Provider(\"PointsProvider\", {})\n</code></pre> Too verbose? <p>If writing <code>prvd.Provider</code> sounds verbose for you, Oh My Prvd aliases the <code>Provider</code> constructor with <code>.new</code>.</p> <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nreturn prvd.new(\"PointsProvider\", PointsProvider)\n</code></pre> <p>For consistency, we recommend using <code>Provider</code> when favorable.</p> <p>The <code>name</code> argument signifies what to identify your provider as. This name must be unique from all other providers. Ideally, you should name your variable the same as the service name, e.g. <code>local PointsProvider</code> would mean <code>prvd.create(\"PointsProvider\", ...)</code>.</p> <p>Notice that you're creating the provider at the bottom of a file, and then returning it. This lets Oh My Prvd to strictly type your provider, something which will be important later.</p>"},{"location":"tutorials/providers/#methods-properties-the-likes","title":"Methods, Properties, The Likes","text":"<p>Providers are just tables at the end of the day. As such, it's dead easy to add methods, properties, and the likes to providers.</p> <p>Let's add a <code>points</code> property to our <code>PointsProvider</code>, which will be a map of a <code>Player</code> and their points:</p> LuauTypeScript <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nPointsProvider.points = {}\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\n\nexport = Provider(\"PointsProvider\", {\n  points: Map&lt;Player, number&gt; = {}\n})\n</code></pre> <p>To instantiate our <code>points</code>, let's also implement a <code>setDefaultPoints</code> method for convenience:</p> LuauTypeScript <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider)\n  player: Player\n)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\n\nexport = Provider(\"PointsProvider\", {\n  points: Map&lt;Player, number&gt; = {}\n\n  setDefaultPoints(player: Player) {\n    this.points.get(player)?.set(10)\n  }\n})\n</code></pre> <p>Notice we are passing <code>self</code> as an argument to our methods, which is of type <code>typeof(PointsProvider)</code>. This allows internal code to use <code>self</code> as a shorthand for the PointsProvider, with <code>self</code> fully typed, while external code can use the colon syntax. Both of these are equivalent:</p> <pre><code>PointsProvider.setDefaultPoints(PointsProvider, player)\nPointsProvider:setDefaultPoints(player)\n</code></pre>"},{"location":"tutorials/providers/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>Providers and the likes can implement lifecycle methods, by having a method that matches its lifecycle name.</p> <p>Oh My Prvd provides a few lifecycle events out of the box:</p> <ul> <li><code>:init</code> runs sequentially before any other lifecycle methods, methods are   expected to be infallible and preferably non-yielding.</li> </ul> <p>??? tip \"Promises\"</p> <pre><code>  If you return a `Promise`, Oh My Prvd will wait for the promise to\n  resolve. Anything with a `:andThen` method and a `:awaitStatus` method\n  will be picked up by Oh My Prvd.\n</code></pre> <ul> <li><code>:start</code> runs concurrently after all other lifecycle methods have been   registered. This means failures and yields do not affect other providers.</li> <li><code>:heartbeat</code> is ran every <code>RunService.HeartBeat</code> and is optimal for responding   to changes in the physics state.</li> <li><code>:step</code> is ran every <code>RunService.Stepped</code> and is optimal for manipulating   physics.</li> <li><code>:render</code> is ran every <code>RunService.RenderStepped</code>. Notably, this lifecycle   event only runs on the client.</li> </ul> <p>In order to maintain this pattern, be sure to set up your provider in the <code>:init</code> method (or earlier; just in the module itself). By the time <code>:start</code> methods are fired, other providers should be available for use.</p> <p>As a rule of thumb, prefer to implement <code>:start</code> unless you need the unique behavior of <code>:init</code>.</p> <p>If you need to modify when a provider loads, you can specify a <code>loadOrder</code> parameter, which defaults to <code>1</code>, e.g. to load before other providers, you can use a <code>loadOrder</code> of <code>0</code>.</p> <p>Let's implement a <code>:start</code> method to our <code>PointsProvider</code>, which will add the player to our points table, and set it to a default value:</p> LuauTypeScript <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\nlocal Players = game:GetService(\"Players\")\n\nlocal PointsProvider = {}\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider)\n  player: Player\n)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nfunction PointsProvider.start(\n  self: typeof(PointsProvider)\n)\n  Players.PlayerAdded:Connect(function(newPlayer)\n    self:setDefaultPoints(newPlayer)\n  end)\n  for _, existingPlayer in pairs(Players:GetPlayers()) do\n    self:setDefaultPoints(existingPlayer)\n  end\nend\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\nimport { Players } from \"@rbxts/services\"\n\nexport = Provider(\"PointsProvider\", {\n  points: Map&lt;Player, number&gt; = {},\n\n  setDefaultPoints(player: Player) {\n    this.points.get(player)?.set(10)\n  }\n\n  start() {\n    Players.PlayerAdded.Connect((newPlayer) =&gt; {\n      this.setDefaultPoints(newPlayer)\n    })\n    for (const existingPlayer in Players.GetPlayers()) {\n      this.setDefaultPoints(existingPlayer)\n    }\n  }\n})\n</code></pre>"},{"location":"tutorials/providers/#memory","title":"Memory","text":"<p>Now we have a problem: theres a memory leak.</p> <p>When we set points for a player, we add the player to the table. What happens when the player leaves? Nothing. Which is an issue.</p> <p>That player's data is forever held onto within the <code>points</code> table. We need to clear out that data when the player leaves. Let's hook up our <code>:start</code> method with the <code>Players.PlayerRemoving</code> event and remove their points:</p> <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\nlocal Players = game:GetService(\"Players\")\n\nlocal PointsProvider = {}\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider)\n  player: Player\n)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nfunction PointsProvider.start(\n  self: typeof(PointsProvider)\n)\n  Players.PlayerAdded:Connect(function(newPlayer)\n    self:setDefaultPoints(player)\n  end)\n  for _, existingPlayer in pairs(Players:GetPlayers()) do\n    self:setDefaultPoints(existingPlayer)\n  end\n  Players.PlayerRemoving:Connect(function(player)\n    self.points[player] = nil\n  end)\nend\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre>"},{"location":"tutorials/providers/#dependencies","title":"Dependencies","text":"<p>Often, providers may depend on other providers, such as a <code>CombatProvider</code> requiring the player's <code>CharacterProvider</code>. Oh my Prvd lets you use providers through dependency injection.</p> <p>First, create a file for a new <code>MathProvider</code> with the following:</p> LuauTypeScript <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal MathProvider = {}\n\nfunction MathProvider.add(\n  self: typeof(PointsProvider),\n  a: number,\n  b: number\n): number\n  -- this method is very expensive!\n  task.wait(5)\n  return a + b\nend\n\nreturn prvd.Provider(\"MathProvider\", MathProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\n\nexport = Provider(\"MathProvider\", {\n  add(a: number, b: number) {\n    // this method is very expensive!\n    task.wait(5)\n    return a + b\n  }\n})\n</code></pre> <p>Then, from <code>PointsProvider</code>, import your newly created <code>MathProvider</code>:</p> <pre><code>local MathProvider = require(script.Parent.MathProvider)\n</code></pre> <p>Finally, just specify your provider <code>use()</code>s another provider:</p> <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\nlocal MathProvider = require(script.Parent.MathProvider)\nlocal Players = game:GetService(\"Players\")\n\nlocal PointsProvider = {}\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider)\n  player: Player\n)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nfunction PointsProvider.start(\n  self: typeof(PointsProvider)\n)\n  Players.PlayerAdded:Connect(function(newPlayer)\n    self:setDefaultPoints(player)\n  end)\n  for _, existingPlayer in pairs(Players:GetPlayers()) do\n    self:setDefaultPoints(existingPlayer)\n  end\n  Players.PlayerRemoving:Connect(function(player)\n    self.points[player] = nil\n  end)\nend\n\nfunction PointsProvider.addPoints(\n  self: typeof(PointsProvider),\n  player: Player,\n  points: number\n)\n  self.points[player] = self.mathProvider:add(\n    self.points[player],\n    points\n  )\nend\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <p>Do not use dependencies outside of lifecycle methods!</p> <p>Oh My Prvd only returns a shadow of the <code>use()</code>d provider. You cannot use it outside of lifecycle methods:</p> <pre><code>[ohmyprvd error(usedBeforeIgnition)]: cannot use provider \"MathProvider\" prior to ignition\n  help: ohmyprvd will inject the dependency for you during runtime, its safe to use the provider inside a lifecycle method\n  more info: team-fireworks.github.io/ohmyprvd/latest/api-reference/general/error-messages#usedbeforeignition\n  stack trace:\n    ohmyprvd.log:118 function throw\n    ohmyprvd.prvd:181 function use\n    PointsService:42\n</code></pre> <p>Behind the scenes, Oh My Prvd will keep track of what dependencies your provider uses, figure out the correct load order for you, and inject your dependencies.</p> <p>This is also why you can't freeze your provider tables - Oh My Prvd will have to modify them.</p> <p>Congratulations! You just successfully wrote your first provider using Oh My Prvd!</p> <p>That was a taste of Oh My Prvd. Later on, you will learn how to register your own lifecycle methods, use Oh My Prvd networking primitives, and creating your own components.</p> <p>Once you're comfortable writing providers, you are ready to take on the rest of what Oh My Prvd offers.</p>"},{"location":"tutorials/best-practices/alternatives/","title":"Alternatives","text":"<p>There are several existing game frameworks for Roblox. Besides Oh My Prvd, you might consider:</p> <ul> <li>Knit by sleitnick</li> <li>Flamework by fireboltofdeath</li> <li>Nevermore by Quenty</li> <li>Proton by sleitnick</li> <li>Pronghorn by Iron Stag Games</li> <li>Lazy Modules by NightLapse Studios</li> <li>Lumin Framework by Lumin Labs</li> </ul> <p>So, why did we make Oh My Prvd?</p> <p>Each of these frameworks solve the same problem in multiple angles. The goal of Oh My Prvd is to take all of the lessons and ideas learned from these projects and build a framework that can solve this problem for good. In addition, all of these frameworks have major drawbacks:</p> <ul> <li>Knit is under long term support with sparse updates and nearing an archive, in   addition it introduces a hefty level of bloat, has subpar types;</li> <li>Flamework requires TypeScript and is tightly coupled with its transformer;</li> <li>Nevermore introduces an outrageous level of bloat and also harder to use,   being geared primarily just for Quenty;</li> <li>Proton is under development and requires TypeScript;</li> <li>Pronghorn does not implement dependency injection, minimal extensibility and   introduces some bloat;</li> <li>Lazy Modules has subpar syntax, somewhat couples code;</li> <li>Lumin Framework only focuses on networking and provides no primitives for   singletons/providers;</li> </ul> <p>Finally:</p> <ul> <li>We think a framework should be distributed as a single module, for decoupling   and extensibility.</li> <li>We think a framework should be designed for both Luau and TypeScript.</li> <li>We think the conventions promoted by other frameworks (e.g. splitting between   services and controllers, forcing games to follow a structure) are   sub-optimal.</li> <li>We have a good enough understanding of the problem to develop something   robust.</li> <li>We think Oh My Prvd should be able to do more than just connect providers.</li> </ul>"},{"location":"tutorials/components/","title":"Components","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/attributes/","title":"Attributes","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/inheritance/","title":"Inheritance","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/usage/","title":"Usage","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/mods/","title":"Mods","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/mods/lifecycle-methods/","title":"Lifecycle Methods","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/","title":"Net","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/events/","title":"Events","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/functions/","title":"Functions","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/middlewares/","title":"Middlewares","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/namespaces/","title":"Namespaces","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"}]}