import luau from "@roblox-ts/luau-ast";
import { PathTranslator } from "@roblox-ts/path-translator";
import { RbxPath, RojoResolver } from "@roblox-ts/rojo-resolver";
import { ProjectType } from "../../Shared/constants";
import { ProjectData } from "../../Shared/types";
import { MultiTransformState } from "..";
import { TransformServices, TryUses } from "../types";
import ts from "typescript";
export declare class TransformState {
    readonly program: ts.Program;
    readonly data: ProjectData;
    readonly services: TransformServices;
    readonly pathTranslator: PathTranslator;
    readonly multiTransformState: MultiTransformState;
    readonly compilerOptions: ts.CompilerOptions;
    readonly rojoResolver: RojoResolver;
    readonly pkgRojoResolvers: Array<RojoResolver>;
    readonly nodeModulesPathMapping: Map<string, string>;
    readonly reverseSymlinkMap: Map<string, string>;
    readonly runtimeLibRbxPath: RbxPath | undefined;
    readonly typeChecker: ts.TypeChecker;
    readonly projectType: ProjectType;
    private readonly sourceFileText;
    hasExportEquals: boolean;
    hasExportFrom: boolean;
    classIdentifierMap: Map<ts.ClassLikeDeclaration, luau.AnyIdentifier>;
    debugRender(node: luau.Node): string;
    debugRenderList(list: luau.List<luau.Statement>): string;
    readonly resolver: ts.EmitResolver;
    private isInReplicatedFirst;
    constructor(program: ts.Program, data: ProjectData, services: TransformServices, pathTranslator: PathTranslator, multiTransformState: MultiTransformState, compilerOptions: ts.CompilerOptions, rojoResolver: RojoResolver, pkgRojoResolvers: Array<RojoResolver>, nodeModulesPathMapping: Map<string, string>, reverseSymlinkMap: Map<string, string>, runtimeLibRbxPath: RbxPath | undefined, typeChecker: ts.TypeChecker, projectType: ProjectType, sourceFile: ts.SourceFile);
    readonly tryUsesStack: TryUses[];
    pushTryUsesStack(): {
        usesReturn: boolean;
        usesBreak: boolean;
        usesContinue: boolean;
    };
    markTryUses(property: keyof TryUses): void;
    popTryUsesStack(): void;
    readonly prereqStatementsStack: luau.List<luau.Statement<luau.SyntaxKind>>[];
    prereq(statement: luau.Statement): void;
    prereqList(statements: luau.List<luau.Statement>): void;
    pushPrereqStatementsStack(): luau.List<luau.Statement<luau.SyntaxKind>>;
    popPrereqStatementsStack(): luau.List<luau.Statement<luau.SyntaxKind>>;
    getLeadingComments(node: ts.Node): luau.List<luau.Comment>;
    capturePrereqs(callback: () => void): luau.List<luau.Statement<luau.SyntaxKind>>;
    capture<T>(callback: () => T): [value: T, prereqs: luau.List<luau.Statement>];
    noPrereqs(callback: () => luau.Expression): luau.Expression<luau.SyntaxKind>;
    readonly hoistsByStatement: Map<ts.Statement | ts.CaseClause, ts.Identifier[]>;
    readonly isHoisted: Map<ts.Symbol, boolean>;
    private getTypeCache;
    getType(node: ts.Node): ts.Type;
    usesRuntimeLib: boolean;
    TS(node: ts.Node, name: string): luau.PropertyAccessExpression;
    createRuntimeLibImport(sourceFile: ts.SourceFile): luau.VariableDeclaration;
    pushToVar(expression: luau.Expression | undefined, name?: string): luau.TemporaryIdentifier;
    pushToVarIfComplex<T extends luau.Expression>(expression: T, name?: string): Extract<T, luau.SimpleTypes> | luau.TemporaryIdentifier;
    pushToVarIfNonId<T extends luau.Expression>(expression: T, name?: string): luau.AnyIdentifier;
    getModuleExports(moduleSymbol: ts.Symbol): ts.Symbol[];
    getModuleExportsAliasMap(moduleSymbol: ts.Symbol): Map<ts.Symbol, string>;
    private getModuleSymbolFromNode;
    private readonly moduleIdBySymbol;
    private getModuleIdFromSymbol;
    setModuleIdBySymbol(moduleSymbol: ts.Symbol, moduleId: luau.AnyIdentifier): void;
    getModuleIdFromNode(node: ts.Node): luau.AnyIdentifier;
    getModuleIdPropertyAccess(idSymbol: ts.Symbol): luau.PropertyAccessExpression | undefined;
    guessVirtualPath(fsPath: string): string;
    symbolToIdMap: Map<ts.Symbol, luau.TemporaryIdentifier>;
    private classElementToObjectKeyMap;
    setClassElementObjectKey(classElement: ts.ClassElement, identifier: luau.AnyIdentifier): void;
    getClassElementObjectKey(classElement: ts.ClassElement): luau.AnyIdentifier | undefined;
}
