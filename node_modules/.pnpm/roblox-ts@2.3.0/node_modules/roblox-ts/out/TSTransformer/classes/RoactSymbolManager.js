"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoactSymbolManager = exports.ROACT_SYMBOL_NAMES = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../../Shared/constants");
const assert_1 = require("../../Shared/util/assert");
const realPathExistsSync_1 = require("../../Shared/util/realPathExistsSync");
const constants_2 = require("../util/jsx/constants");
const typescript_1 = __importDefault(require("typescript"));
exports.ROACT_SYMBOL_NAMES = {
    Component: "Component",
    PureComponent: "PureComponent",
    Fragment: "Fragment",
    Element: "Element",
};
class RoactSymbolManager {
    constructor(typeChecker, roactIndexSourceFile) {
        var _a, _b, _c, _d;
        this.symbols = new Map();
        this.jsxIntrinsicNameMap = new Map();
        const roactNamespace = (_b = (_a = roactIndexSourceFile.locals) === null || _a === void 0 ? void 0 : _a.get(typescript_1.default.escapeLeadingUnderscores("Roact"))) === null || _b === void 0 ? void 0 : _b.valueDeclaration;
        (0, assert_1.assert)(roactNamespace);
        const roactExports = roactNamespace.symbol.exports;
        (0, assert_1.assert)(roactExports);
        for (const symbolName of Object.values(exports.ROACT_SYMBOL_NAMES)) {
            const symbol = roactExports.get(typescript_1.default.escapeLeadingUnderscores(symbolName));
            (0, assert_1.assert)(symbol);
            this.symbols.set(symbolName, typescript_1.default.skipAlias(symbol, typeChecker));
        }
        for (const symbol of typeChecker.getJsxIntrinsicTagNamesAt(roactIndexSourceFile)) {
            (0, assert_1.assert)(symbol.valueDeclaration && typescript_1.default.isPropertySignature(symbol.valueDeclaration));
            (0, assert_1.assert)(symbol.valueDeclaration.type && typescript_1.default.isTypeReferenceNode(symbol.valueDeclaration.type));
            const className = (_c = symbol.valueDeclaration.type.typeArguments) === null || _c === void 0 ? void 0 : _c[0].getText();
            (0, assert_1.assert)(className);
            this.jsxIntrinsicNameMap.set(typescript_1.default.skipAlias(symbol, typeChecker), className);
        }
        const jsxInstanceType = roactExports.get(typescript_1.default.escapeLeadingUnderscores("JsxInstance"));
        (0, assert_1.assert)(jsxInstanceType);
        const jsxInstanceTypeDeclaration = (_d = jsxInstanceType.declarations) === null || _d === void 0 ? void 0 : _d[0];
        (0, assert_1.assert)(jsxInstanceTypeDeclaration);
        const jsxInstanceTypeType = typeChecker.getTypeAtLocation(jsxInstanceTypeDeclaration);
        const changeSymbol = typeChecker.getPropertyOfType(jsxInstanceTypeType, constants_2.CHANGE_ATTRIBUTE_NAME);
        (0, assert_1.assert)(changeSymbol);
        this.symbols.set(constants_2.CHANGE_ATTRIBUTE_NAME, typescript_1.default.skipAlias(changeSymbol, typeChecker));
        const eventSymbol = typeChecker.getPropertyOfType(jsxInstanceTypeType, constants_2.EVENT_ATTRIBUTE_NAME);
        (0, assert_1.assert)(eventSymbol);
        this.symbols.set(constants_2.EVENT_ATTRIBUTE_NAME, typescript_1.default.skipAlias(eventSymbol, typeChecker));
    }
    static create(data, program, typeChecker) {
        var _a, _b;
        const pkgPath = path_1.default.join(data.nodeModulesPath, constants_1.RBXTS_SCOPE, "roact");
        const pkgJsonPath = (0, realPathExistsSync_1.realPathExistsSync)(path_1.default.join(pkgPath, "package.json"));
        if (pkgJsonPath !== undefined) {
            const pkgJson = fs_extra_1.default.readJsonSync(pkgJsonPath);
            const typesPath = (0, realPathExistsSync_1.realPathExistsSync)(path_1.default.join(pkgPath, (_b = (_a = pkgJson.types) !== null && _a !== void 0 ? _a : pkgJson.typings) !== null && _b !== void 0 ? _b : "index.d.ts"));
            if (typesPath !== undefined) {
                const roactIndexSourceFile = program.getSourceFile(typesPath);
                if (roactIndexSourceFile) {
                    return new RoactSymbolManager(typeChecker, roactIndexSourceFile);
                }
            }
        }
        const roactIndexSourceFilePath = path_1.default.join(data.nodeModulesPath, constants_1.RBXTS_SCOPE, "roact", "src", "index.d.ts");
        const roactIndexSourceFile = program.getSourceFile(roactIndexSourceFilePath);
        if (roactIndexSourceFile) {
            return new RoactSymbolManager(typeChecker, roactIndexSourceFile);
        }
    }
    getSymbolOrThrow(symbolName) {
        const symbol = this.symbols.get(symbolName);
        (0, assert_1.assert)(symbol, `Could not find symbol for ${symbolName}`);
        return symbol;
    }
    getIntrinsicElementClassNameFromSymbol(symbol) {
        return this.jsxIntrinsicNameMap.get(symbol);
    }
}
exports.RoactSymbolManager = RoactSymbolManager;
//# sourceMappingURL=RoactSymbolManager.js.map