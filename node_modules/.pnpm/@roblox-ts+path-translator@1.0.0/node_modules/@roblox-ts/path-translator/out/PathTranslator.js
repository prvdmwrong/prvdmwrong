"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathTranslator = void 0;
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const assert_1 = require("./util/assert");
class PathInfo {
    constructor(dirName, fileName, exts) {
        this.dirName = dirName;
        this.fileName = fileName;
        this.exts = exts;
    }
    static from(filePath) {
        const dirName = path_1.default.dirname(filePath);
        const parts = filePath.slice(dirName.length + path_1.default.sep.length).split(".");
        const fileName = parts.shift();
        const exts = parts.map(v => "." + v);
        (0, assert_1.assert)(fileName !== undefined);
        return new PathInfo(dirName, fileName, exts);
    }
    extsPeek(depth = 0) {
        return this.exts[this.exts.length - (depth + 1)];
    }
    join() {
        return path_1.default.join(this.dirName, [this.fileName, ...this.exts].join(""));
    }
}
class PathTranslator {
    constructor(rootDir, outDir, buildInfoOutputPath, declaration) {
        this.rootDir = rootDir;
        this.outDir = outDir;
        this.buildInfoOutputPath = buildInfoOutputPath;
        this.declaration = declaration;
    }
    makeRelativeFactory(from = this.rootDir, to = this.outDir) {
        return (pathInfo) => path_1.default.join(to, path_1.default.relative(from, pathInfo.join()));
    }
    getOutputPath(filePath) {
        const makeRelative = this.makeRelativeFactory();
        const pathInfo = PathInfo.from(filePath);
        if ((pathInfo.extsPeek() === constants_1.TS_EXT || pathInfo.extsPeek() === constants_1.TSX_EXT) && pathInfo.extsPeek(1) !== constants_1.D_EXT) {
            pathInfo.exts.pop();
            if (pathInfo.fileName === constants_1.INDEX_NAME) {
                pathInfo.fileName = constants_1.INIT_NAME;
            }
            pathInfo.exts.push(constants_1.LUA_EXT);
        }
        return makeRelative(pathInfo);
    }
    getOutputDeclarationPath(filePath) {
        const makeRelative = this.makeRelativeFactory();
        const pathInfo = PathInfo.from(filePath);
        if ((pathInfo.extsPeek() === constants_1.TS_EXT || pathInfo.extsPeek() === constants_1.TSX_EXT) && pathInfo.extsPeek(1) !== constants_1.D_EXT) {
            pathInfo.exts.pop();
            pathInfo.exts.push(constants_1.DTS_EXT);
        }
        return makeRelative(pathInfo);
    }
    getOutputTransformedPath(filePath) {
        const makeRelative = this.makeRelativeFactory();
        const pathInfo = PathInfo.from(filePath);
        if (pathInfo.extsPeek(1) === constants_1.D_EXT) {
            pathInfo.exts.splice(pathInfo.exts.length - 2, 0, constants_1.TRANSFORMED_EXT);
        }
        else {
            pathInfo.exts.splice(pathInfo.exts.length - 1, 0, constants_1.TRANSFORMED_EXT);
        }
        return makeRelative(pathInfo);
    }
    getInputPaths(filePath) {
        const makeRelative = this.makeRelativeFactory(this.outDir, this.rootDir);
        const possiblePaths = new Array();
        const pathInfo = PathInfo.from(filePath);
        if (pathInfo.extsPeek() === constants_1.LUA_EXT && pathInfo.fileName !== constants_1.INDEX_NAME) {
            pathInfo.exts.pop();
            pathInfo.exts.push(constants_1.TS_EXT);
            possiblePaths.push(makeRelative(pathInfo));
            pathInfo.exts.pop();
            pathInfo.exts.push(constants_1.TSX_EXT);
            possiblePaths.push(makeRelative(pathInfo));
            pathInfo.exts.pop();
            if (pathInfo.fileName === constants_1.INIT_NAME) {
                const originalFileName = pathInfo.fileName;
                pathInfo.fileName = constants_1.INDEX_NAME;
                pathInfo.exts.push(constants_1.TS_EXT);
                possiblePaths.push(makeRelative(pathInfo));
                pathInfo.exts.pop();
                pathInfo.exts.push(constants_1.TSX_EXT);
                possiblePaths.push(makeRelative(pathInfo));
                pathInfo.exts.pop();
                pathInfo.fileName = originalFileName;
            }
            pathInfo.exts.push(constants_1.LUA_EXT);
        }
        if (this.declaration) {
            if ((pathInfo.extsPeek() === constants_1.TS_EXT || pathInfo.extsPeek() === constants_1.TSX_EXT) && pathInfo.extsPeek(1) === constants_1.D_EXT) {
                const tsExt = pathInfo.exts.pop();
                (0, assert_1.assert)(tsExt);
                pathInfo.exts.pop();
                pathInfo.exts.push(constants_1.TS_EXT);
                possiblePaths.push(makeRelative(pathInfo));
                pathInfo.exts.pop();
                pathInfo.exts.push(constants_1.TSX_EXT);
                possiblePaths.push(makeRelative(pathInfo));
                pathInfo.exts.pop();
                pathInfo.exts.push(constants_1.D_EXT);
                pathInfo.exts.push(tsExt);
            }
        }
        possiblePaths.push(makeRelative(pathInfo));
        return possiblePaths;
    }
    getImportPath(filePath, isNodeModule = false) {
        const makeRelative = this.makeRelativeFactory();
        const pathInfo = PathInfo.from(filePath);
        if (pathInfo.extsPeek() === constants_1.TS_EXT || pathInfo.extsPeek() === constants_1.TSX_EXT) {
            pathInfo.exts.pop();
            if (pathInfo.extsPeek() === constants_1.D_EXT) {
                pathInfo.exts.pop();
            }
            if (pathInfo.fileName === constants_1.INDEX_NAME) {
                pathInfo.fileName = constants_1.INIT_NAME;
            }
            pathInfo.exts.push(constants_1.LUA_EXT);
        }
        return isNodeModule ? pathInfo.join() : makeRelative(pathInfo);
    }
}
exports.PathTranslator = PathTranslator;
//# sourceMappingURL=PathTranslator.js.map