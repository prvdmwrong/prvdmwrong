"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RojoResolver = exports.RbxPathParent = exports.NetworkType = exports.FileRelation = exports.RbxType = void 0;
const ajv_1 = __importDefault(require("ajv"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const PACKAGE_ROOT = path_1.default.join(__dirname, "..");
const LUA_EXT = ".lua";
const JSON_EXT = ".json";
const INIT_NAME = "init";
const SERVER_SUBEXT = ".server";
const CLIENT_SUBEXT = ".client";
const MODULE_SUBEXT = "";
const ajv = new ajv_1.default();
const ROJO_FILE_REGEX = /^.+\.project\.json$/;
const ROJO_DEFAULT_NAME = "default.project.json";
const ROJO_OLD_NAME = "roblox-project.json";
var RbxType;
(function (RbxType) {
    RbxType[RbxType["ModuleScript"] = 0] = "ModuleScript";
    RbxType[RbxType["Script"] = 1] = "Script";
    RbxType[RbxType["LocalScript"] = 2] = "LocalScript";
    RbxType[RbxType["Unknown"] = 3] = "Unknown";
})(RbxType || (exports.RbxType = RbxType = {}));
const SUB_EXT_TYPE_MAP = new Map([
    [MODULE_SUBEXT, RbxType.ModuleScript],
    [SERVER_SUBEXT, RbxType.Script],
    [CLIENT_SUBEXT, RbxType.LocalScript],
]);
const DEFAULT_ISOLATED_CONTAINERS = [
    ["StarterPack"],
    ["StarterGui"],
    ["StarterPlayer", "StarterPlayerScripts"],
    ["StarterPlayer", "StarterCharacterScripts"],
    ["StarterPlayer", "StarterCharacter"],
];
const CLIENT_CONTAINERS = [["StarterPack"], ["StarterGui"], ["StarterPlayer"]];
const SERVER_CONTAINERS = [["ServerStorage"], ["ServerScriptService"]];
var FileRelation;
(function (FileRelation) {
    FileRelation[FileRelation["OutToOut"] = 0] = "OutToOut";
    FileRelation[FileRelation["OutToIn"] = 1] = "OutToIn";
    FileRelation[FileRelation["InToOut"] = 2] = "InToOut";
    FileRelation[FileRelation["InToIn"] = 3] = "InToIn";
})(FileRelation || (exports.FileRelation = FileRelation = {}));
var NetworkType;
(function (NetworkType) {
    NetworkType[NetworkType["Unknown"] = 0] = "Unknown";
    NetworkType[NetworkType["Client"] = 1] = "Client";
    NetworkType[NetworkType["Server"] = 2] = "Server";
})(NetworkType || (exports.NetworkType = NetworkType = {}));
function stripRojoExts(filePath) {
    const ext = path_1.default.extname(filePath);
    if (ext === LUA_EXT) {
        filePath = filePath.slice(0, -ext.length);
        const subext = path_1.default.extname(filePath);
        if (subext === SERVER_SUBEXT || subext === CLIENT_SUBEXT) {
            filePath = filePath.slice(0, -subext.length);
        }
    }
    else if (ext === JSON_EXT) {
        filePath = filePath.slice(0, -ext.length);
    }
    return filePath;
}
function arrayStartsWith(a, b) {
    const minLength = Math.min(a.length, b.length);
    for (let i = 0; i < minLength; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
function isPathDescendantOf(filePath, dirPath) {
    return dirPath === filePath || !path_1.default.relative(dirPath, filePath).startsWith("..");
}
class Lazy {
    constructor(getValue) {
        this.getValue = getValue;
        this.isInitialized = false;
    }
    get() {
        if (!this.isInitialized) {
            this.isInitialized = true;
            this.value = this.getValue();
        }
        return this.value;
    }
    set(value) {
        this.isInitialized = true;
        this.value = value;
    }
}
const SCHEMA_PATH = path_1.default.join(PACKAGE_ROOT, "rojo-schema.json");
const validateRojo = new Lazy(() => ajv.compile(JSON.parse(fs_extra_1.default.readFileSync(SCHEMA_PATH).toString())));
function isValidRojoConfig(value) {
    return validateRojo.get()(value) === true;
}
exports.RbxPathParent = Symbol("Parent");
class RojoResolver {
    static findRojoConfigFilePath(projectPath) {
        const warnings = new Array();
        const defaultPath = path_1.default.join(projectPath, ROJO_DEFAULT_NAME);
        if (fs_extra_1.default.pathExistsSync(defaultPath)) {
            return { path: defaultPath, warnings };
        }
        const candidates = new Array();
        for (const fileName of fs_extra_1.default.readdirSync(projectPath)) {
            if (fileName !== ROJO_DEFAULT_NAME && (fileName === ROJO_OLD_NAME || ROJO_FILE_REGEX.test(fileName))) {
                candidates.push(path_1.default.join(projectPath, fileName));
            }
        }
        if (candidates.length > 1) {
            warnings.push(`Multiple *.project.json files found, using ${candidates[0]}`);
        }
        return { path: candidates[0], warnings };
    }
    constructor() {
        this.warnings = new Array();
        this.rbxPath = new Array();
        this.partitions = new Array();
        this.filePathToRbxPathMap = new Map();
        this.isolatedContainers = [...DEFAULT_ISOLATED_CONTAINERS];
        this.isGame = false;
    }
    warn(str) {
        this.warnings.push(str);
    }
    getWarnings() {
        return this.warnings;
    }
    static fromPath(rojoConfigFilePath) {
        const resolver = new RojoResolver();
        resolver.parseConfig(path_1.default.resolve(rojoConfigFilePath), true);
        return resolver;
    }
    static synthetic(basePath) {
        const resolver = new RojoResolver();
        resolver.parseTree(basePath, "", { $path: basePath }, true);
        return resolver;
    }
    static fromTree(basePath, tree) {
        const resolver = new RojoResolver();
        resolver.parseTree(basePath, "", tree, true);
        return resolver;
    }
    parseConfig(rojoConfigFilePath, doNotPush = false) {
        const realPath = fs_extra_1.default.realpathSync(rojoConfigFilePath);
        if (fs_extra_1.default.pathExistsSync(realPath)) {
            let configJson;
            try {
                configJson = JSON.parse(fs_extra_1.default.readFileSync(realPath).toString());
            }
            finally {
                if (isValidRojoConfig(configJson)) {
                    this.parseTree(path_1.default.dirname(rojoConfigFilePath), configJson.name, configJson.tree, doNotPush);
                }
                else {
                    this.warn(`RojoResolver: Invalid configuration! ${ajv.errorsText(validateRojo.get().errors)}`);
                }
            }
        }
        else {
            this.warn(`RojoResolver: Path does not exist "${rojoConfigFilePath}"`);
        }
    }
    parseTree(basePath, name, tree, doNotPush = false) {
        if (!doNotPush)
            this.rbxPath.push(name);
        if (tree.$path !== undefined) {
            this.parsePath(path_1.default.resolve(basePath, typeof tree.$path === "string" ? tree.$path : tree.$path.optional));
        }
        if (tree.$className === "DataModel") {
            this.isGame = true;
        }
        for (const childName of Object.keys(tree).filter(v => !v.startsWith("$"))) {
            this.parseTree(basePath, childName, tree[childName]);
        }
        if (!doNotPush)
            this.rbxPath.pop();
    }
    parsePath(itemPath) {
        const realPath = fs_extra_1.default.pathExistsSync(itemPath) ? fs_extra_1.default.realpathSync(itemPath) : itemPath;
        if (path_1.default.extname(itemPath) === LUA_EXT) {
            this.filePathToRbxPathMap.set(itemPath, [...this.rbxPath]);
        }
        else {
            const isDirectory = fs_extra_1.default.pathExistsSync(realPath) && fs_extra_1.default.statSync(realPath).isDirectory();
            if (isDirectory && fs_extra_1.default.readdirSync(realPath).includes(ROJO_DEFAULT_NAME)) {
                this.parseConfig(path_1.default.join(itemPath, ROJO_DEFAULT_NAME), true);
            }
            else {
                this.partitions.unshift({
                    fsPath: itemPath,
                    rbxPath: [...this.rbxPath],
                });
                if (isDirectory) {
                    this.searchDirectory(itemPath);
                }
            }
        }
    }
    searchDirectory(directory, item) {
        const realPath = fs_extra_1.default.realpathSync(directory);
        const children = fs_extra_1.default.readdirSync(realPath);
        if (children.includes(ROJO_DEFAULT_NAME)) {
            this.parseConfig(path_1.default.join(directory, ROJO_DEFAULT_NAME));
            return;
        }
        if (item)
            this.rbxPath.push(item);
        for (const child of children) {
            const childPath = path_1.default.join(directory, child);
            const childRealPath = fs_extra_1.default.realpathSync(childPath);
            if (fs_extra_1.default.statSync(childRealPath).isFile() && child !== ROJO_DEFAULT_NAME && ROJO_FILE_REGEX.test(child)) {
                this.parseConfig(childPath);
            }
        }
        for (const child of children) {
            const childPath = path_1.default.join(directory, child);
            const childRealPath = fs_extra_1.default.realpathSync(childPath);
            if (fs_extra_1.default.statSync(childRealPath).isDirectory()) {
                this.searchDirectory(childPath, child);
            }
        }
        if (item)
            this.rbxPath.pop();
    }
    getRbxPathFromFilePath(filePath) {
        filePath = path_1.default.resolve(filePath);
        const rbxPath = this.filePathToRbxPathMap.get(filePath);
        if (rbxPath) {
            return rbxPath;
        }
        for (const partition of this.partitions) {
            if (isPathDescendantOf(filePath, partition.fsPath)) {
                const stripped = stripRojoExts(filePath);
                const relativePath = path_1.default.relative(partition.fsPath, stripped);
                const relativeParts = relativePath === "" ? [] : relativePath.split(path_1.default.sep);
                if (relativeParts[relativeParts.length - 1] === INIT_NAME) {
                    relativeParts.pop();
                }
                return partition.rbxPath.concat(relativeParts);
            }
        }
    }
    getRbxTypeFromFilePath(filePath) {
        var _a;
        const subext = path_1.default.extname(path_1.default.basename(filePath, path_1.default.extname(filePath)));
        return (_a = SUB_EXT_TYPE_MAP.get(subext)) !== null && _a !== void 0 ? _a : RbxType.Unknown;
    }
    getContainer(from, rbxPath) {
        if (this.isGame) {
            if (rbxPath) {
                for (const container of from) {
                    if (arrayStartsWith(rbxPath, container)) {
                        return container;
                    }
                }
            }
        }
    }
    getFileRelation(fileRbxPath, moduleRbxPath) {
        const fileContainer = this.getContainer(this.isolatedContainers, fileRbxPath);
        const moduleContainer = this.getContainer(this.isolatedContainers, moduleRbxPath);
        if (fileContainer && moduleContainer) {
            if (fileContainer === moduleContainer) {
                return FileRelation.InToIn;
            }
            else {
                return FileRelation.OutToIn;
            }
        }
        else if (fileContainer && !moduleContainer) {
            return FileRelation.InToOut;
        }
        else if (!fileContainer && moduleContainer) {
            return FileRelation.OutToIn;
        }
        else {
            return FileRelation.OutToOut;
        }
    }
    isIsolated(rbxPath) {
        return this.getContainer(this.isolatedContainers, rbxPath) !== undefined;
    }
    getNetworkType(rbxPath) {
        if (this.getContainer(SERVER_CONTAINERS, rbxPath)) {
            return NetworkType.Server;
        }
        if (this.getContainer(CLIENT_CONTAINERS, rbxPath)) {
            return NetworkType.Client;
        }
        return NetworkType.Unknown;
    }
    static relative(rbxFrom, rbxTo) {
        const maxLength = Math.max(rbxFrom.length, rbxTo.length);
        let diffIndex = maxLength;
        for (let i = 0; i < maxLength; i++) {
            if (rbxFrom[i] !== rbxTo[i]) {
                diffIndex = i;
                break;
            }
        }
        const result = new Array();
        if (diffIndex < rbxFrom.length) {
            for (let i = 0; i < rbxFrom.length - diffIndex; i++) {
                result.push(exports.RbxPathParent);
            }
        }
        for (let i = diffIndex; i < rbxTo.length; i++) {
            result.push(rbxTo[i]);
        }
        return result;
    }
    getPartitions() {
        return this.partitions;
    }
}
exports.RojoResolver = RojoResolver;
//# sourceMappingURL=RojoResolver.js.map