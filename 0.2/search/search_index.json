{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"LuauTypeScript <pre><code>local prvd = require(\"@pkg/prvdmwrong\")\nlocal CharacterProvider = require(\"./character-provider\")\n\nlocal CombatProvider = {}\nCombatProvider.characterProvider = prvd.use(CharacterProvider)\n\nfunction CombatProvider:onStart()\n  print(\"Hello, Prvd 'M Wrong!\")\nend\n\nfunction CombatProvider.performMove(self: typeof(CombatController), move: CombatMove)\n  local character = self.characterProvider:awaitCharacter()\n  -- do something with the character\nend\n\nreturn prvd(CombatProvider)\n</code></pre> <pre><code>import { Provider, use, type OnStart } from \"@rbxts/prvdmwrong\"\nimport { CharacterProvider } from \"./character-provider\"\n\n@Provider()\nexport class CombatProvider implements OnStart {\n  public characterProvider = use(CharacterProvider)\n\n  public onStart() {\n    print(\"Hello, Prvd 'M Wrong!\")\n  }\n\n  public performMove(move: CombatMove) {\n    const character = this.characterProvider.awaitCharacter()\n    // do something with the character\n  }\n}\n</code></pre>   Scroll down for a quick look at the three main highlights"},{"location":"#prvd-m-wrong","title":"Prvd 'M Wrong","text":"<p> Prvd 'M Wrong is a service provider framework for a next-generation Roblox. </p> <p> Once installed, your game will become your money back. Prvd 'M Wrong accelerates the process with providers, connecting the top-level design of your game. Choose to mix in networking and components as you need. Randoms will approach you and ask, \"are you wealthy or do you make a six-figure salary?\" </p> <p> Cherish a development experience that fades into the background, freeing you to build faster and prove 'm wrong. It's the swaggest framework in town! </p> <p>Tutorials \u00b7 Download \u00b7  Batteries included</p>"},{"location":"#1-providers","title":"\u2460 Providers","text":"<p>Prvd 'M Wrong introduces providers for your game logic. These provide specific functions within your game, e.g. you might create a <code>SaveDataProvider</code> to manage save files or a <code>CameraProvider</code> to handle player camera movement.</p> <p>Create providers to handle the top level logic of your game:</p> LuauTypeScript <pre><code>-- Create Luau providers by calling the package itself.\nlocal CoinsProvider = {}\nreturn prvd(CoinsProvider)\n</code></pre> <pre><code>// Create TypeScript providers by using the Provider decorator on a class.\n@Provider()\nexport class CoinsProvider {}\n</code></pre> <p>Providers are just plain modules. It's easy to implement more methods, properties, and the likes into a provider:</p> LuauTypeScript <pre><code>local CoinsProvider = {}\n-- Alias our provider's type for complete type-safety\ntype Self = typeof(CoinsProvider)\n-- Providers can have properties...\nCoinsProvider.balance = {}\n\n-- ...and methods...\nfunction CoinsProvider.addCoins(self: Self, player: Player, coins: number)\n  -- ...all properties are accessible through `self`!\n  self.coins[person] += coins\nend\n\nreturn prvd(CoinsProvider)\n</code></pre> <pre><code>@Provider()\nexport class CoinsProvider {\n  // Providers can have properties...\n  balance: Map&lt;Player, number&gt; = {},\n\n  // ...and methods...\n  addCoins(player: Player, coins: number) {\n    // ...all properties are accessible through `this`!\n    this.coins[person] += coins\n  }\n})\n</code></pre> <p>Providers can <code>use()</code> other providers. Prvd 'M Wrong will provide type-safety, autocomplete, and figure out a corresponding load order for you:</p> LuauTypeScript <pre><code>-- For example, say this rewards provider requires the coins provider.\nlocal RewardsProvider = {}\ntype Self = typeof(CoinsProvider)\n-- Just specify this provider `use()`-s the coins provider...\nRewardsProvider.coinsProvider = prvd.use(CoinsProvider)\n\nfunction RewardsProvider.addWinRewards(self: Self, player: Player)\n  -- ...and enjoy complete type-safety!\n  self.coinsProvider:addCoins(player, 30)\nend\n\nreturn prvd.new(RewardsProvider)\n</code></pre> <pre><code>// For example, say this rewards provider requires the coins provider.\n@Provider({})\nexport class RewardsProvider {\n  // Just specify this provider `use()`-s the coins provider...\n  coinsProvider = use(CoinsProvider)\n\n  addCoins(person: Player) {\n    // ...and enjoy complete type-safety!\n    this.coinsProvider:addCoins(player, coins)\n  }\n}\n</code></pre> <p>Finally, preload your providers, then start Prvd 'M Wrong, and you're off to the races:</p> LuauTypeScript <pre><code>-- `preload` loads all ModuleScript instances from an array.\n-- This lets Prvd 'M Wrong register providers.\nprvd.preload(ServerScriptService.Providers:GetDescendants())\n-- Now, Prvd 'M Wrong can be started!\nprvd.start(options)\n</code></pre> <pre><code>// `preload` loads all ModuleScript instances from an array.\n// This lets Prvd 'M Wrong register providers.\npreload(ServerScriptService.Providers.GetDescendants())\n// Now, Prvd 'M Wrong can be started!\nstart(options)\n</code></pre>"},{"location":"#2-mixins","title":"\u2461 Mixins","text":"<p>Prvd 'M Wrong is featherlight by design, and provides best-in-class packages to mix-in whenever needed.</p>"},{"location":"#3-extensible","title":"\u2462 Extensible","text":"<p>Prvd 'M Wrong brings comprehensive APIs for extending the framework.</p> <p>Here's one of the common ones, <code>Lifecycle</code> to implement your own lifecycle methods:</p> LuauTypeScript <pre><code>-- This interface satisfies our method!\ntype OnCharacterAdded = {\n  onCharacterAdded(self: unknown, character: Model) -&gt; ()\n}\n\n-- `fireConcurrent` is a built-in lifecycle handler that spawns listeners.\nlocal characterAdded = Lifecycle(\"onCharacterAdded\", fireConcurrent)\n\n-- Now fire the lifecycle method!\nif (LocalPlayer.Character) then\n  characterAdded:fire(LocalPlayer.Character)\nend\nLocalPlayer.CharacterAdded:Connect(function(character)\n  characterAdded:fire(character)\nend)\n</code></pre> <pre><code>// This interface satisfies our method!\ninterface OnCharacterAdded {\n  onCharacterAdded(character: Model): void\n}\n\n// `fireConcurrent` is a built-in lifecycle handler that spawns listeners.\nconst characterAdded = Lifecycle(\"onCharacterAdded\", fireConcurrent)\n\n// Now fire the lifecycle method!\nif (LocalPlayer.Character) {\n  characterAdded.fire(LocalPlayer.Character)\n}\nLocalPlayer.CharacterAdded.Connect((character) =&gt; {\n  characterAdded.fire(character)\n})\n</code></pre> <p>A provider can then hook onto the lifecycle:</p> LuauTypeScript <pre><code>local CombatProvider = {}\n\nfunction CombatProvider:onCharacterAdded(character: Model)\n  local rootPart: BasePart = assert(character:FindFirstChild(\"HumanoidRootPart\"))\n  -- do something with rootPart\nend\n\nreturn prvd(CombatProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/prvdmwrong\"\n\n@Provider({})\nexport class CombatProvider implements OnCharacterAdded {\n  onCharacterAdded(character) {\n    const rootPart: BasePart = assert(character:FindFirstChild(\"HumanoidRootPart\"))\n    // do something with rootPart\n  }\n}\n</code></pre> <p>Scripts can also use Prvd 'M Wrong's assortments of hooks. You often use either <code>onStart</code> or <code>awaitStart</code> if another script requires Prvd 'M Wrong to be started:</p> LuauTypeScript <pre><code>-- Let's track if Prvd 'M Wrong has started.\nlocal hasStarted = false\n\n-- This function is spawned when Prvd 'M Wrong starts.\nprvd.onStart(function()\n  print(\"Prvd 'M Wrong has started!\")\n  hasStarted = true\nend)\n\n-- This yields until Prvd 'M Wrong starts.\nprvd.awaitStart()\nassert(hasStarted == true)\n</code></pre> <pre><code>// Let's track if Prvd 'M Wrong has started.\nlet hasStarted = false\n\n// This function is spawned when Prvd 'M Wrong starts.\nonStart(() =&gt; {\n  print(\"Prvd 'M Wrong has started!\")\n  hasStarted = true\n})\n\n// This yields until Prvd 'M Wrong starts.\nawaitStart()\nassert(hasStarted === true)\n</code></pre>"},{"location":"extras/","title":"Extras","text":"<p>Welcome to the Extras! It's a wealth of resources surrounding Prvd 'M Wrong. Explore open-source projects using Prvd 'M Wrong, download brand assets, and more.</p>"},{"location":"extras/#commonly-used","title":"Commonly Used","text":"<ul> <li> <p> Backgrounds</p> <p>Download high quality backgrounds designed for Prvd 'M Wrong, optimized for various resolutions.</p> </li> <li> <p> Projects</p> <p>Find various open-source projects to see Prvd 'M Wrong used in a real setting, accompanied by in-depth explanations that shows the ropes of the library.</p> </li> </ul>"},{"location":"extras/backgrounds/","title":"Backgrounds","text":"<p>Download high quality backgrounds designed for Prvd 'M Wrong, optimized for these resolutions:</p> <ul> <li>Ultrawide (7680 x 1440)</li> <li>Widescreen (2560 x 1440)</li> </ul> <p>These backgrounds are copyrighted by Team Fireworks and are intended for personal use only. You may not use these backgrounds for commercial use or distribution without explicit written consent.</p>"},{"location":"extras/backgrounds/#machinery","title":"Machinery","text":"<p>Detailed, sprawling illustration of Prvd 'M Wrong's underground machinery. Packed with clues and references to packages and libraries. Designed for seamless horizontal tiling. Not suitable for OLED screens.</p> <p></p> <p> Download Ultrawide  Download Widescreen</p>"},{"location":"extras/projects/","title":"Projects","text":"<p>Here, you can find various open-source projects to see Prvd 'M Wrong used in a real setting, accompanied by in-depth explanations that shows the ropes of the library.</p>"},{"location":"extras/projects/#prvd-m-wrong-obby-for-prvd-m-wrong-01","title":"Prvd 'M Wrong Obby (for Prvd 'M Wrong 0.1)","text":"<p>  Read the explanation  Play on Roblox  Source code on GitHub</p> <p>See how Prvd 'M Wrong can be used to build a simple obby, decked with a JToH-esque client objects provider, a checkpoints provider, a networking provider, and a debug provider.</p>"},{"location":"extras/projects/obby/","title":"Prvd 'M Wrong Obby","text":""},{"location":"extras/projects/obby/#prvd-m-wrong-obby","title":"Prvd 'M Wrong Obby","text":"<p>See how Prvd 'M Wrong can be used to build a simple obby, decked with a JToH-esque client objects provider, a checkpoints provider, a networking provider, and a debug provider.</p> <p>  Play on Roblox  Source code on GitHub</p>"},{"location":"extras/projects/obby/#explanation","title":"Explanation","text":"<p>This game serves as a feature complete example of the core Prvd 'M Wrong package. It serves as motivation for creating other games using the core package, utilizing a partially managed Rojo configuration to leverage Roblox Studio as a visual representation and external editors for code editing.</p> <p>Some games, for example obbies, might contain lots of different client objects, e.g. spinners, damage bricks, and jump pads to name a few.</p> <p>Some of these client objects can be done with basic constraints, e.g. a spinner can be made with a CylindricalConstraint and some attachments, while a damage brick would need a remote event to damage the player.</p> <p>For more complex client objects, it would be ergonomic to use ModuleScripts and run it with a corresponding client object, which perhaps will have the CollectionService \"Objects\" tag and a \"Script\" string attribute to specify the ObjectScript to use. Let's call these <code>ObjectScript</code>s, which will satisfy this type:</p> <pre><code>export type ObjectScript = {\n  type: \"ObjectScript\",\n  runner: (\n    self: ObjectScript,\n    object: Instance,\n    scope: { unknown }\n  ) -&gt; (),\n}\n</code></pre> <p>The <code>ObjectScript</code> interface will use a table for future extensions, such as specifying it's own type guards, or enable some feature flags.</p> <p>Note the <code>ObjectScript:runner(object, scope)</code> method, which receives both the target object and a scope, which will be cleaned up once the client object unloads.</p> <p>Let's create <code>ObjectProvider</code>s for the server and the client. During startup, the server <code>ObjectProvider</code> moves objects from the workspace to the ServerStorage. This then uses the <code>NetProvider</code> and connects to the <code>GetObjects</code> remote, using the <code>PlayerProvider</code> to validate if a player has client objects. If not, the <code>ObjectProvider</code> sends a clone of the client objects to the player.</p> <p>The players <code>ObjectProvider</code> will wait for the client objects to appear as a child of the player. Then, every object with the CollectionService tag \"Objects\" and a \"Script\" string attribute gets processed, with a corresponding <code>ObjectScript</code>. It will prepare a runner thread, link the object and its script to it, and then enables it.</p> <p>Checkpoints are kept separate from client objects to be tracked by the <code>PlayerProvider</code>s alongside with session info. The <code>PlayerProvider</code> tracks all players and assigns each some <code>PlayerSession</code> information, which satisfies this type:</p> <pre><code>export type PlayerSession = {\n  checkpoint: number,\n  hasObjects: boolean,\n\n  startedAt: number,\n  leaderstats: Folder &amp; {\n    Stage: IntValue,\n    Time: IntValue,\n  },\n}\n</code></pre> <p>The <code>PlayerProvider</code> increments a player <code>PlayerSession.checkpoint</code> once the player touches the next consecutive checkpoint. This also uses the <code>NetProvider</code> to fire the <code>NextCheckpoint</code> event, which is picked up by the players <code>GuiProvider</code> to create some confetti.</p> <p>The <code>ObjectsProvider</code> sets a player <code>PlayerSession.hasObjects</code> to true once it sends the client objects to prevent a player from firing the <code>GetObjects</code> event several times.</p> <p>Finally, the <code>PlayerProvider</code> sets a players <code>PlayerSession.startedAt</code> to <code>os.clock()</code> as soon as the player joined, and increments a players <code>PlayerSession.leaderstats</code> until the player reached the final checkpoint.</p> <p>This game uses some other providers too:</p> <ul> <li>The <code>DebugProvider</code> copies all Tools from its StudioTools folder if the   current session is running on Roblox Studio. It comes with a Noclip tool to   help ease playtesting the obby.</li> <li>The <code>GuiProvider</code> manages the games user interface using Fusion 0.3. Notably,   this provider tracks the <code>NextCheckpoint</code> event to increment a value based on   the players current checkpoint. It then observes that for firing confetti or   toggling a win message.</li> <li>The <code>NetProvider</code> wraps around RemoteEvents and eases using them. It serves as   a replacement for the planned <code>prvdmwrong-net</code> package, which has not been   released. Other providers will use the <code>t</code> package to typecheck remote data.</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This section provides detailed reference documentation for working with Oh My Prvd. For an introduction to Prvd 'M Wrong, see the Learn section.</p> <p>Under construction</p> <p>The reference is under construction - information may be incomplete or missing.</p>"},{"location":"reference/#types","title":"Types","text":"<p>For convenience, API pages will have it's corresponding type member annotated in both Luau and TypeScript:</p> LuauTypeScript <pre><code>function prvd.start(\n  options: {\n    logLevel: \"none\" | \"verbose\" | nil,\n    profiling: boolean?,\n  }?\n): ()\n</code></pre> <pre><code>export const start: (\n  options: Partial&lt;Options&gt; = {\n    logLevel: \"none\",\n    profiling: RunService.IsStudio(),\n  }\n) =&gt; void\n</code></pre> <p>While these type annotations are kept to be accurate, it is ultimately psuedo-code included as developer aid. For fully accurate and syntactically valid type information, please refer to the source code directly.</p>"},{"location":"reference/#conventions","title":"Conventions","text":"<p>The reference uses several conventions, explained below:</p> <ul> <li> <p> Constructors</p> <p>The cube icon is denotes a constructor, a special type of function for creating and initializing objects.</p> </li> <li> <p> Enumerations</p> <p>The list icon denotes an enumeration, which represent a set of named   constants.</p> </li> <li> <p> Functions</p> <p>The code icon denotes a function, fundamental primitives that runs a specific task.</p> </li> <li> <p> Hooks</p> <p>The branch icon denotes a hook, a special type of function that allows you to \"hook into\" Prvd 'M Wrong to perform side effects.</p> </li> <li> <p> Types</p> <p>The checklist icon denotes a type, which defines the interface and possible values of an object.</p> </li> </ul>"},{"location":"reference/#packages","title":"Packages","text":"<p>The reference is broken down into functional packages.</p>"},{"location":"reference/#core","title":"Core","text":"<p>Details the <code>prvdmwrong</code> package, which implements provider primitives and everything needed to bootstrap a game:</p> <ul> <li>Providers \u00b7 Create and use game providers</li> <li>Lifecycles \u00b7 Create lifecycle methods and events</li> <li>Modding \u00b7 Extend Prvd 'M Wrong's core functionality</li> <li>Internal \u00b7 Lower level primitives for library   authors</li> <li>Types \u00b7 Types exported by the core package</li> </ul>"},{"location":"reference/#lifecycles","title":"Lifecycles","text":"<p>Details the <code>prvdmwrong-lifecycles</code> package, which implements a \"small\" amount of lifecycle events.</p> <ul> <li>Runtime \u00b7 Lifecycle methods for the Roblox   runtime</li> <li>Players \u00b7 Lifecycle methods for the Players   service</li> </ul>"},{"location":"reference/#net","title":"Net","text":"<p>Details the <code>prvdmwrong-net</code> package, which implements networking primitives for providers.</p> Unreleased <p>This package is unreleased, as such no documentation is available at this time.</p>"},{"location":"reference/#components","title":"Components","text":"<p>Details the <code>prvdmwrong-components</code> package, which implements a component system for providers.</p> Unreleased <p>This package is unreleased, as such no documentation is available at this time.</p>"},{"location":"reference/#debugger","title":"Debugger","text":"<p>Details the <code>prvdmwrong-debugger</code> package, which implements a quality of life debugger for working with Prvd 'M Wrong.</p> Unreleased <p>This package is unreleased, as such no documentation is available at this time.</p>"},{"location":"reference/error-messages/","title":"Error Messages","text":"Reference"},{"location":"reference/error-messages/#error-messages","title":"Error Messages","text":"<p>Prvd 'M Wrong attaches an error ID with every console log message. This is used to uniquely identify what kind of error or message you're seeing.</p> <p>Use the search box below to paste in or type an error ID, and it will scroll to the details for you.</p> <p></p>"},{"location":"reference/error-messages/#alreadystarted","title":"alreadyStarted","text":"<pre><code>cannot start more than once\n</code></pre> <p>Thrown by: <code>prvd.start(options)</code></p> <p>You attempted to start Prvd 'M Wrong when it has already started.</p>"},{"location":"reference/error-messages/#cannotregister","title":"cannotRegister","text":"<pre><code>cannot register provider; `MyProvider.onStart` should be a function\n</code></pre> <p>Thrown by: <code>prvd.Provider</code>, <code>prvd.new</code></p> <p>You attempted to register a new provider, but Prvd 'M Wrong caught something wrong. The error includes a more specific message which can be used to diagnose the issue. Typically it is one of the following:</p> <ul> <li>A provider of the same name was already registered</li> <li>You have frozen the provider table, which prevents dependency injection</li> <li>You provided a mismatched type for a built-in method/property</li> <li>You forgot to include a non-empty string as a <code>name</code></li> </ul>"},{"location":"reference/error-messages/#cannotusenonprovider","title":"cannotUseNonProvider","text":"<pre><code>`use()` must be given a provider\n</code></pre> <p>Thrown by: <code>prvd.use</code></p> <p>You attempted to <code>use()</code> an object that was not registered as a provider.</p>"},{"location":"reference/error-messages/#invalidloadparent","title":"invalidLoadParent","text":"<p>Thrown by: <code>prvd.preload</code></p> <pre><code>preload must be given an instance\n</code></pre> <p><code>prvd.preload(instances, predicate)</code> expected you to give it a parent instance to load from, but you gave it something else.</p>"},{"location":"reference/error-messages/#invalidonignitioncallback","title":"invalidOnIgnitionCallback","text":"<pre><code>`onStart` must be given callbacks\n</code></pre> <p>Thrown by: <code>prvd.onStart</code></p> <p><code>prvd.onStart(callback)</code> expected you to give it a callback to spawn after startup finishes, but you gave it something else.</p>"},{"location":"reference/error-messages/#registerafterignition","title":"registerAfterIgnition","text":"<pre><code>cannot register providers after startup\n</code></pre> <p>Thrown by: <code>@Provider</code>, <code>prvd.new</code></p> <p>You attempted to register a provider after startup.</p> <p>Make sure you've preloaded all providers you will use prior to startup, and that no other module registers a provider after startup.</p>"},{"location":"reference/error-messages/#oniniterror","title":"onInitError","text":"<p>Thrown by: <code>prvd.start</code></p> <pre><code>cannot initialize MyProvider; attempted to index nil with 'property'\n</code></pre> <p>Prvd 'M Wrong could not finish its initialization lifecycle as a provider threw an error in it's <code>:init</code> method. The error includes a more specific message which can be used to diagnose the issue.</p>"},{"location":"reference/error-messages/#requireerror","title":"requireError","text":"<pre><code>cannot require ServerScriptService.Providers.MyProvider; Module code did not return exactly one value\n</code></pre> <p>Thrown by: <code>prvd.preload</code>,</p> <p><code>prvd.preload(instances, predicate)</code> loaded a module which threw an error that Prvd 'M Wrong cannot handle. The error includes a more specific message which can be used to diagnose the issue.</p>"},{"location":"reference/error-messages/#unknown","title":"unknown","text":"<pre><code>unknown error: attempt to call a nil value\nhelp: this indicates Prvd 'M Wrong isn't reporting errors correctly, please file an issue\n</code></pre> <p>Prvd 'M Wrong ran into an error, but cannot associate it with an error message. This is a fallback error type which shouldn't be seen by end users, because it indicates that Prvd 'M Wrong is not reporting errors correctly.</p>"},{"location":"reference/error-messages/#useafterstartup","title":"useAfterStartup","text":"<pre><code>cannot use other providers after startup\n</code></pre> <p>Thrown by: <code>prvd.use</code></p> <p>You tried to <code>use()</code> another provider after Prvd 'M Wrong started.</p> <p>Make sure every provider explicitly <code>use()</code>s all providers it needs. This lets Prvd 'M Wrong figure out a corresponding load order.</p>"},{"location":"reference/error-messages/#usedbeforestartup","title":"usedBeforeStartup","text":"<pre><code>cannot use provider \"MyProvider\" prior to startup\nhelp: prvdmwrong will inject the dependency for you during runtime, its safe to use the provider inside a lifecycle method\n</code></pre> <p>You tried to access the contents of a <code>use()</code>d provider prior to startup.</p> <p>Prvd 'M Wrong will inject the dependency for you when ignited and figure out a corresponding load order. Make sure when you use another provider, you're using it from a lifecycle method.</p>"},{"location":"reference/core/","title":"Index","text":"Reference"},{"location":"reference/core/#core","title":"Core","text":"<p>This package contains fundamental primitives for creating and using game providers. Contains everything needed to bootstrap a Roblox game and utilities for extending the core Prvd 'M Wrong package.</p> <p>Install this through your preferred package manager:</p> WallyPesdeNPMPNPMYarn <pre><code>[dependencies]\n  prvd = \"prvdmwrong/core@0.2.0-dev.5\"\n</code></pre> <pre><code>dependencies:\n- prvd:\n  - name: prvdmwrong/core\n  - version: 0.2.0-dev.5\n</code></pre> <pre><code>$ npm i @prvdmwrong/core\n</code></pre> <pre><code>$ pnpm i @prvdmwrong/core\n</code></pre> <pre><code>$ yarn add @prvdmwrong/core\n</code></pre>"},{"location":"reference/core/#providers","title":"Providers","text":"<ul> <li> Provider</li> <li> new</li> <li> StartupStatus</li> <li> preload</li> <li> start</li> <li> use</li> <li> awaitStart</li> <li> onStart</li> </ul>"},{"location":"reference/core/#types","title":"Types","text":"<ul> <li> Lifecycle</li> <li> OnInit</li> <li> OnStart</li> <li> Options</li> <li> Provider</li> </ul>"},{"location":"reference/core/#lifecycles","title":"Lifecycles","text":"<ul> <li> Lifecycle</li> <li> fireConcurrent</li> <li> fireSequential</li> <li> onLifecycleRegistered</li> <li> onLifecycleUnregistered</li> </ul>"},{"location":"reference/core/#modding","title":"Modding","text":"<ul> <li> getStartupOptions</li> <li> getStartupStatus</li> <li> onProviderConstructed</li> <li> onProviderUsed</li> </ul>"},{"location":"reference/core/#internal","title":"Internal","text":"<ul> <li> defineMetadata</li> <li> deleteMetadata</li> <li> getMetadata</li> <li> registerAll</li> <li> registerDependency</li> <li> registerMethod</li> <li> unregisterMethod</li> </ul>"},{"location":"reference/core/internal/","title":"Index","text":"Reference Core"},{"location":"reference/core/internal/#internal","title":"Internal","text":"<p>Lower level primitives for library authors.</p> <p>Beware</p> <p>These are internal APIs are made for library authors. Do not touch this unless you know what you're doing, unless you'd like to be fired.</p>"},{"location":"reference/core/internal/#members","title":"Members","text":"<ul> <li> defineMetadata</li> <li> deleteMetadata</li> <li> getMetadata</li> <li> registerAll</li> <li> registerDependency</li> <li> registerMethod</li> <li> unregisterMethod</li> </ul>"},{"location":"reference/core/internal/define-metadata/","title":"defineMetadata","text":"Reference Core Internal function since v0.1"},{"location":"reference/core/internal/define-metadata/#definemetadata","title":"defineMetadata","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> LuauTypeScript <pre><code>function prvd.defineMetadata(\n  object: unknown,\n  key: string,\n  value: unknown,\n): ()\n</code></pre> <pre><code>export const defineMetadata: (\n  object: unknown,\n  key: string,\n  value: unknown,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/internal/define-metadata/#parameters","title":"Parameters","text":""},{"location":"reference/core/internal/define-metadata/#object-unknown","title":"object <code>: unknown</code>","text":""},{"location":"reference/core/internal/define-metadata/#key-string","title":"key <code>: string</code>","text":""},{"location":"reference/core/internal/define-metadata/#value-unknown","title":"value <code>: unknown</code>","text":""},{"location":"reference/core/internal/delete-metadata/","title":"deleteMetadata","text":"Reference Core Internal function since v0.1"},{"location":"reference/core/internal/delete-metadata/#deletemetadata","title":"deleteMetadata","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> LuauTypeScript <pre><code>function prvd.deleteMetadata(\n  object: unknown,\n  key: string,\n): ()\n</code></pre> <pre><code>export const deleteMetadata: (\n  object: unknown,\n  key: string,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/internal/delete-metadata/#parameters","title":"Parameters","text":""},{"location":"reference/core/internal/delete-metadata/#object-unknown","title":"object <code>: unknown</code>","text":""},{"location":"reference/core/internal/delete-metadata/#key-string","title":"key <code>: string</code>","text":""},{"location":"reference/core/internal/get-metadata/","title":"getMetadata","text":"Reference Core Internal function since v0.1"},{"location":"reference/core/internal/get-metadata/#getmetadata","title":"getMetadata","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> LuauTypeScript <pre><code>function prvd.getMetadata(\n  object: unknown,\n  key: string,\n): unknown?\n</code></pre> <pre><code>export const getMetadata: &lt;T&gt;(\n  object: unknown,\n  key: string\n) =&gt; T | undefined\nexport const deleteMetadata: (\n  object: unknown,\n  key: string,\n  property?: string,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/internal/get-metadata/#parameters","title":"Parameters","text":""},{"location":"reference/core/internal/get-metadata/#object-unknown","title":"object <code>: unknown</code>","text":""},{"location":"reference/core/internal/get-metadata/#key-string","title":"key <code>: string</code>","text":""},{"location":"reference/core/internal/get-metadata/#returns","title":"Returns","text":"<p>The metadata value.</p>"},{"location":"reference/core/internal/register-all/","title":"registerAll","text":"Reference Core Internal function since v0.2"},{"location":"reference/core/internal/register-all/#registerall","title":"registerAll","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/internal/register-dependency/","title":"registerDependency","text":"Reference Core Internal function since v0.2"},{"location":"reference/core/internal/register-dependency/#registerdependency","title":"registerDependency","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/internal/register-method/","title":"registerMethod","text":"Reference Core Internal function since v0.2"},{"location":"reference/core/internal/register-method/#registermethod","title":"registerMethod","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/internal/unregister-method/","title":"unregisterMethod","text":"Reference Core Internal function since v0.2"},{"location":"reference/core/internal/unregister-method/#unregistermethod","title":"unregisterMethod","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/lifecycles/","title":"Index","text":"Reference Core"},{"location":"reference/core/lifecycles/#lifecycles","title":"Lifecycles","text":"<p>Primitives for implementing lifecycle methods and events.</p>"},{"location":"reference/core/lifecycles/#members","title":"Members","text":"<ul> <li> Lifecycle \u00b7 Create lifecycle objects</li> <li> fireConcurrent \u00b7 Lifecycle handler   that spawns listeners concurrently</li> <li> fireSequential \u00b7 Lifecycle handler   that runs listeners sequentially</li> <li> onLifecycleRegistered \u00b7   Called when an object registers a lifecycle</li> <li> onLifecycleUnregistered   \u00b7 Called when an object unregisters a lifecycle</li> </ul>"},{"location":"reference/core/lifecycles/fire-concurrent/","title":"fireConcurrent","text":"Reference Core Lifecycles function since v0.2"},{"location":"reference/core/lifecycles/fire-concurrent/#fireconcurrent","title":"fireConcurrent","text":"<p>A function that spawns all listeners of a lifecycle asynchronously. Intended to be used as the <code>fire</code> argument of the lifecycle constructor.</p> LuauTypeScript <pre><code>function prvd.fireConcurrent(\n  self: Lifecycle,\n  ...: unknown\n): ()\n</code></pre> <pre><code>export function fireConcurrent: (\n  lifecycle: Lifecycle,\n  ...args: unknown[]\n) =&gt; void\n</code></pre>"},{"location":"reference/core/lifecycles/fire-concurrent/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/fire-concurrent/#self-lifecycle","title":"self <code>: Lifecycle</code>","text":"<p>The lifecycle object that should have its listeners ran.</p>"},{"location":"reference/core/lifecycles/fire-concurrent/#unknown","title":"... <code>: unknown</code>","text":"<p>Arguments to call the listeners' method.</p>"},{"location":"reference/core/lifecycles/fire-concurrent/#learn-more","title":"Learn More","text":"<ul> <li>Lifecycles tutorial</li> </ul>"},{"location":"reference/core/lifecycles/fire-sequential/","title":"fireSequential","text":"Reference Core Lifecycles function since v0.2"},{"location":"reference/core/lifecycles/fire-sequential/#firesequential","title":"fireSequential","text":"<p>A function that runs all listeners of a lifecycle in order synchronously. Intended to be used as the <code>fire</code> argument of the lifecycle constructor.</p> LuauTypeScript <pre><code>function prvd.fireSequential(\n  self: Lifecycle,\n  ...: unknown\n): ()\n</code></pre> <pre><code>export function fireSequential: (\n  lifecycle: Lifecycle,\n  ...args: unknown[]\n) =&gt; void\n</code></pre>"},{"location":"reference/core/lifecycles/fire-sequential/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/fire-sequential/#self-lifecycle","title":"self <code>: Lifecycle</code>","text":"<p>The lifecycle object that should have its listeners ran.</p>"},{"location":"reference/core/lifecycles/fire-sequential/#unknown","title":"... <code>: unknown</code>","text":"<p>Arguments to call the listeners' method.</p>"},{"location":"reference/core/lifecycles/fire-sequential/#learn-more","title":"Learn More","text":"<ul> <li>Lifecycles tutorial</li> </ul>"},{"location":"reference/core/lifecycles/lifecycle/","title":"Lifecycle","text":"Reference Core Lifecycles constructor since v0.2"},{"location":"reference/core/lifecycles/lifecycle/#lifecycle","title":"Lifecycle","text":"<p>Constructs and returns a new lifecycle within Oh My Prvd. Lifecycles are special event dispatchers that can hook onto a provider's method.</p> LuauTypeScript <pre><code>function prvd.Lifecycle(\n  method: string,\n  fire: (self: Lifecycle, ...unknown) -&gt; ()\n): Lifecycle\n</code></pre> <pre><code>export function Lifecycle: (\n  method: string,\n  fire: (lifecycle: Lifecycle, ...args: unknown[]) =&gt; void\n) =&gt; Lifecycle\n</code></pre>"},{"location":"reference/core/lifecycles/lifecycle/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/lifecycle/#method-string","title":"method <code>: string</code>","text":"<p>The provider method that this lifecycle should hook onto. During startup, Oh My Prvd will register all lifecycles on a provider.</p>"},{"location":"reference/core/lifecycles/lifecycle/#fire-self-lifecycle-unknown-","title":"fire <code>: (self: Lifecycle, ...unknown) -&gt; ()</code>","text":"<p>A method to fire the lifecycle method. It receives itself and the arguments passed to it. For convenience, Prvd 'M Wrong provides two methods you can use:</p> <ul> <li><code>fireConcurrent(self, ...)</code> which spawns all listeners   concurrently</li> <li><code>fireSequential(self, ...)</code> which runs all listeners   sequentially</li> </ul>"},{"location":"reference/core/lifecycles/lifecycle/#returns","title":"Returns","text":"<p>A freshly constructed lifecycle.</p>"},{"location":"reference/core/lifecycles/lifecycle/#learn-more","title":"Learn More","text":"<ul> <li>Lifecycles tutorial</li> </ul>"},{"location":"reference/core/lifecycles/on-lifecycle-registered/","title":"onLifecycleRegistered","text":"Reference Core Lifecycles hook since v0.1"},{"location":"reference/core/lifecycles/on-lifecycle-registered/#onlifecycleregistered","title":"onLifecycleRegistered","text":"<p>Called when an object registers a lifecycle method. Handlers are expected to be infallible and non-yielding. The handler receives the constructed provider.</p> LuauTypeScript <pre><code>function prvd.onLifecycleRegistered(\n  method: string,\n  handler: (Provider&lt;unknown&gt;) -&gt; ()\n): ()\n</code></pre> <pre><code>export const onLifecycleRegistered: (\n  method: string,\n  handler: (provider: Provider&lt;unknown&gt;) =&gt; void\n) =&gt; void\n</code></pre>"},{"location":"reference/core/lifecycles/on-lifecycle-registered/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/on-lifecycle-registered/#method-string","title":"method <code>: string</code>","text":"<p>The method that is registered. During startup, all providers will have its lifecycles registered.</p>"},{"location":"reference/core/lifecycles/on-lifecycle-registered/#handler-providerunknown-void","title":"handler <code>: (Provider&lt;unknown&gt;) -&gt; void</code>","text":"<p>A handler for providers that register the specified method. It receives the provider which implements the method.</p>"},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/","title":"onLifecycleUnregistered","text":"Reference Core Lifecycles hook since v0.1"},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/#onlifecycleunregistered","title":"onLifecycleUnregistered","text":"<p>Called when an object unregisters a lifecycle method. Handlers are expected to be infallible and non-yielding. The handler receives the constructed provider.</p> LuauTypeScript <pre><code>function prvd.onLifecycleUnregistered(\n  method: string,\n  handler: (Provider&lt;unknown&gt;) -&gt; ()\n): ()\n</code></pre> <pre><code>export const onLifecycleUnregistered: (\n  method: string,\n  handler: (provider: Provider&lt;unknown&gt;) =&gt; void\n) =&gt; void\n</code></pre>"},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/#method-string","title":"method <code>: string</code>","text":"<p>The method that is unregistered.</p>"},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/#handler-providerunknown-void","title":"handler <code>: (Provider&lt;unknown&gt;) -&gt; void</code>","text":"<p>A handler for providers that unregisters the specified method. It receives the provider which unregistered the method.</p>"},{"location":"reference/core/modding/","title":"Index","text":"Reference Core"},{"location":"reference/core/modding/#modding","title":"Modding","text":"<p>Hooks and utilities for extending the core Prvd 'M Wrong package.</p> <p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/modding/get-startup-options/","title":"getStartupOptions","text":"Reference Core Modding function since v0.1"},{"location":"reference/core/modding/get-startup-options/#getignitionoptions","title":"getIgnitionOptions","text":"<p>Returns the startup configuration options. Options are reconciled with default values.</p> LuauTypeScript <pre><code>function prvd.getIgnitionOptions(): Options\n</code></pre> <pre><code>export const getIgnitionOptions: () =&gt; Options\n</code></pre>"},{"location":"reference/core/modding/get-startup-options/#returns","title":"Returns","text":"<p>The startup options, reconciled with default values.</p>"},{"location":"reference/core/modding/get-startup-status/","title":"getStartupStatus","text":"Reference Core Modding"},{"location":"reference/core/modding/get-startup-status/#getstartupstatus","title":"getStartupStatus","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/modding/on-provider-constructed/","title":"onProviderConstructed","text":"Reference Core Modding hook since v0.1"},{"location":"reference/core/modding/on-provider-constructed/#onproviderconstructed","title":"onProviderConstructed","text":"<p>Called just before Prvd 'M Wrong returns a newly constructed provider. Handlers are expected to be infallible and non-yielding. The handler receives the constructed provider.</p> LuauTypeScript <pre><code>function prvd.onProviderConstructed(\n  handler: (Provider&lt;unknown&gt;) -&gt; ()\n) -&gt; (),\n</code></pre> <pre><code>export const onProviderConstructed: (\n  handler: (provider: Provider&lt;object&gt;) =&gt; void,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/modding/on-provider-constructed/#parameters","title":"Parameters","text":""},{"location":"reference/core/modding/on-provider-constructed/#handler-providerunknown-void","title":"handler <code>: (Provider&lt;unknown&gt;) -&gt; void</code>","text":"<p>A handler that is called just before a newly constructed provider is returned. It receives the provider.</p>"},{"location":"reference/core/modding/on-provider-used/","title":"onProviderUsed","text":"Reference Core Modding hook since v0.1"},{"location":"reference/core/modding/on-provider-used/#onproviderused","title":"onProviderUsed","text":"<p>Called just before Prvd 'M Wrong returns a used provider. Handlers are expected to be infallible and non-yielding. The handler receives the used provider.</p> LuauTypeScript <pre><code>function prvd.onProviderUsed(\n  handler: (Provider&lt;unknown&gt;) -&gt; ()\n) -&gt; (),\n</code></pre> <pre><code>export const onProviderUsed: (\n  handler: (provider: Provider&lt;object&gt;) =&gt; void,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/modding/on-provider-used/#parameters","title":"Parameters","text":""},{"location":"reference/core/modding/on-provider-used/#handler-providerunknown-void","title":"handler <code>: (Provider&lt;unknown&gt;) -&gt; void</code>","text":"<p>A handler that is called when a provider has been used. It receives the target provider.</p>"},{"location":"reference/core/providers/","title":"Index","text":"Reference Core"},{"location":"reference/core/providers/#providers","title":"Providers","text":"<p>Fundamental primitives for creating and using game providers.</p>"},{"location":"reference/core/providers/#members","title":"Members","text":"<ul> <li> Provider \u00b7 Construct TypeScript providers   within Oh My Prvd</li> <li> new \u00b7 Construct Luau providers within Oh   My Prvd</li> <li> StartupStatus \u00b7 All startup   phases Prvd 'M Wrong will be in</li> <li> preload \u00b7 Preload an array of ModuleScripts</li> <li> start \u00b7 Starts Prvd 'M Wrong</li> <li> use \u00b7 Use a provider within Prvd 'M Wrong</li> <li> awaitStart \u00b7 Yields until startup   finishes</li> <li> onStart \u00b7 Spawned when startup finishes</li> </ul>"},{"location":"reference/core/providers/await-start/","title":"awaitStart","text":"Reference Core Providers hook since v0.1"},{"location":"reference/core/providers/await-start/#awaitstart","title":"awaitStart","text":"<p>Yields the calling thread just before startup finishes. If Prvd 'M Wrong has already started, the thread will continue.</p> LuauTypeScript <pre><code>function prvd.awaitStart(): ()\n</code></pre> <pre><code>export const awaitStart: () =&gt; void\n</code></pre>"},{"location":"reference/core/providers/await-start/#learn-more","title":"Learn More","text":"<ul> <li>startup tutorial</li> </ul>"},{"location":"reference/core/providers/new/","title":"new","text":"Reference Core Providers constructor since v0.1"},{"location":"reference/core/providers/new/#new","title":"new","text":"Luau <p>Constructs and returns a new Luau provider within Prvd 'M Wrong. Providers must be created before calling <code>prvd.start(options)</code>.</p> <pre><code>function prvd.new&lt;T&gt;(\n  provider: T\n): Provider&lt;T&gt;\n</code></pre> <p>Shorthand syntax</p> <p>It's recommended to call the package as a shorthand for <code>prvd.new</code>:</p> <pre><code>local prvd = -- Import Prvd 'M Wrong however you'd like!\nlocal MyProvider = {}\nreturn prvd(MyProvider)\n</code></pre> <p>Beware the difference</p> <p>Both <code>prvd.new</code> and <code>@Provider()</code> appeal for different environments. <code>prvd.new()</code> is used as a function to construct Luau providers. Contrast to <code>@Provider()</code>, which is used as a class decorator to construct TypeScript decorators.</p>"},{"location":"reference/core/providers/new/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/new/#provider-t","title":"provider <code>: T</code>","text":"<p>The methods and properties of the provider. All lifecycle methods will be registered during startup. The provider can specify a <code>name</code> property for debug profiling, and falls back to using <code>debug.info</code>. The provider may also specify a <code>loadOrder</code> property which dictates when the provider is loaded, and defaults to one.</p>"},{"location":"reference/core/providers/new/#returns-providert","title":"Returns <code>: Provider&lt;T&gt;</code>","text":"<p>A freshly registered provider.</p>"},{"location":"reference/core/providers/new/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"reference/core/providers/on-start/","title":"onStart","text":"Reference Core Providers workflow since v0.1"},{"location":"reference/core/providers/on-start/#onstart","title":"onStart","text":"<p>Queues a callback to be called just before startup finishes. If Prvd 'M Wrong has already started, the callback will be spawned immediately.</p> LuauTypeScript <pre><code>function prvd.onStart(\n  callback: () -&gt; ()\n): ()\n</code></pre> <pre><code>export const onStart: (\n  callback: () =&gt; void\n) =&gt; void\n</code></pre>"},{"location":"reference/core/providers/on-start/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/on-start/#callback-","title":"callback <code>: () -&gt; ()</code>","text":"<p>The callback to be spawned just before startup finishes.</p>"},{"location":"reference/core/providers/on-start/#learn-more","title":"Learn More","text":"<ul> <li>startup tutorial</li> </ul>"},{"location":"reference/core/providers/preload/","title":"preload","text":"Reference Core Providers function since v0.1"},{"location":"reference/core/providers/preload/#preload","title":"preload","text":"<p>Preload the specified parent by requiring all <code>ModuleScripts</code> within it. An optional <code>predicate</code> function can be provided to filter modules.</p> LuauTypeScript <pre><code>function prvd.loadChildren(\n  parent: { Instance },\n  predicate: ((ModuleScript) -&gt; boolean)?\n): { unknown }\n</code></pre> <pre><code>export const preload: (\n  parent: Instance[],\n  predicate?: (module: ModuleScript) =&gt; boolean\n) =&gt; unknown[]\n</code></pre>"},{"location":"reference/core/providers/preload/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/preload/#parent-instance","title":"parent <code>: { Instance }</code>","text":"<p>An array of instances to load from. Often paired with <code>:GetChildren()</code> or <code>:GetDescendants()</code>.</p>"},{"location":"reference/core/providers/preload/#predicate-modulescript-boolean","title":"predicate <code>: (ModuleScript) -&gt; boolean</code>","text":"<p>An optional predicate function that will be called to filter the modules to load with.</p>"},{"location":"reference/core/providers/preload/#learn-more","title":"Learn More","text":"<ul> <li>Startup tutorial</li> </ul>"},{"location":"reference/core/providers/provider/","title":"Provider","text":"Reference Core Providers constructor since v0.1"},{"location":"reference/core/providers/provider/#provider","title":"Provider","text":"<p>Returns a decorator that when applied to a TypeScript class registers it as a provider within Prvd 'M Wrong. Providers must be created before calling <code>prvd.start(options)</code>.</p> TypeScript <pre><code>export const Provider: (\n  options?: {\n    loadOrder?: number\n  }\n) =&gt; &lt;T extends new () =&gt; InstanceType&lt;T&gt;&gt;(\n  provider: T\n) =&gt; void\n</code></pre> <p>Name is inferred</p> <p>Prvd 'M Wrong will infer the name of the class provider for memory profiling.</p> <p>Beware the difference</p> <p>Both <code>prvd.new</code> and <code>@Provider()</code> appeal for different environments. <code>prvd.new()</code> is used as a function to construct Luau providers. Contrast to <code>@Provider()</code>, which is used as a class decorator to construct TypeScript decorators.</p>"},{"location":"reference/core/providers/provider/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/provider/#options-loadorder-number","title":"options <code>: { loadOrder?: number }</code>","text":"<p>Additional options that will be applied onto the provider. It is recommended to specify <code>loadOrder</code> through this argument.</p>"},{"location":"reference/core/providers/provider/#returns-t-extends-new-instancetypetprovider-t-void","title":"Returns <code>: &lt;T extends new () =&gt; InstanceType&lt;T&gt;&gt;(provider: T) =&gt; void</code>","text":"<p>A decorator that when used on a TypeScript class registers a freshly constructed provider.</p>"},{"location":"reference/core/providers/provider/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"reference/core/providers/start/","title":"start","text":"Reference Core Providers function since v0.1"},{"location":"reference/core/providers/start/#start","title":"start","text":"<p>Starts Prvd 'M Wrong. Expected to be called once in an environment, e.g. once on the server and once on the client.</p> <p>All necessary providers should be preloaded before calling this as newly created providers will not run its lifecycle events.</p> LuauTypeScript <pre><code>function prvd.start(\n  options: {\n    logLevel: \"none\" | \"verbose\" | nil,\n    profiling: boolean?,\n  }?\n): ()\n</code></pre> <pre><code>export const start: (\n  options: Partial&lt;Options&gt; = {\n    logLevel: \"none\",\n    profiling: RunService.IsStudio(),\n  }\n) =&gt; void\n</code></pre>"},{"location":"reference/core/providers/start/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/start/#options-partialoptions","title":"options <code>: Partial&lt;Options&gt;</code>","text":"<p>Configures how Prvd 'M Wrong will start. The following are the available configuration options:</p> <ul> <li><code>logLevel: \"none\" | \"verbose\"</code> configures if Prvd 'M Wrong should log trace   information to the console, defaults to none.</li> <li><code>profiling: boolean</code> configures if built-in lifecycle events should be   profiled with <code>debug.setmemorycategory</code> and <code>debug.profilebegin</code>, defaults to   whether the current session is running in Roblox Studio.</li> </ul>"},{"location":"reference/core/providers/start/#learn-more","title":"Learn More","text":"<ul> <li>startup tutorial</li> </ul>"},{"location":"reference/core/providers/startup-status/","title":"StartupStatus","text":"Reference Core Providers enumeration since v0.1"},{"location":"reference/core/providers/startup-status/#startupstatus","title":"StartupStatus","text":"<p>An enumeration of all defined startup status Prvd 'M Wrong will be in.</p> <p>This enum is not useful outside of Prvd 'M Wrong itself; prefer to work with <code>awaitStart()</code> and <code>onStart(callback)</code></p> LuauTypeScript <pre><code>prvd.StartupStatus = {\n  Pending = \"IgnitionStatus.Pending\",\n  startup = \"IgnitionStatus.startup\",\n  Ignited = \"IgnitionStatus.Ignited\"\n}\n</code></pre> <pre><code>export enum StartupStatus {\n  Pending = \"IgnitionStatus.Pending\",\n  startup = \"IgnitionStatus.startup\",\n  Ignited = \"IgnitionStatus.Ignited\"\n}\n</code></pre>"},{"location":"reference/core/providers/startup-status/#items","title":"Items","text":""},{"location":"reference/core/providers/startup-status/#pending-startupstatuspending","title":"Pending <code>: StartupStatus.Pending</code>","text":"<p>Indicates that <code>prvd.start()</code> has not been called yet. Calls to <code>prvd.use()</code> and <code>prvd.Provider()</code> are safe.</p>"},{"location":"reference/core/providers/startup-status/#startup-startupstatusstartup","title":"startup <code>: StartupStatus.startup</code>","text":"<p>Indicates that <code>prvd.start()</code> has been called, but the startup process has not finished. Calls to <code>prvd.use()</code> and <code>prvd.Provider()</code> will throw an error.</p>"},{"location":"reference/core/providers/startup-status/#ignited-startupstatusignited","title":"Ignited <code>: StartupStatus.Ignited</code>","text":"<p>Indicates that the startup process has finished. Calls to <code>prvd.use()</code> and <code>prvd.Provider()</code> will throw an error.</p> <p>Awaiting threads from <code>prvd.awaitStart()</code> and queued callbacks from <code>prvd.onStart()</code> will be spawned just before the startup status is set to this.</p>"},{"location":"reference/core/providers/use/","title":"use","text":"Reference Core Providers function since v0.1"},{"location":"reference/core/providers/use/#use","title":"use","text":"<p>Uses a provider within Prvd 'M Wrong. During startup, Prvd 'M Wrong will inject the dependencies your provider uses.</p> LuauTypeScript <pre><code>function prvd.use&lt;T&gt;(\n  provider: Provider&lt;T&gt;\n): T\n</code></pre> <pre><code>export const use: &lt;T extends object&gt;(\n  provider: Provider&lt;T&gt;\n) =&gt; T\n</code></pre> <p>Do not use dependencies outside of lifecycle methods</p> <p>Prvd 'M Wrong only returns a shadow of the <code>use()</code>d provider. You cannot use it outside of lifecycle methods</p> <p>Behind the scenes, Prvd 'M Wrong will keep track of what dependencies your provider uses, figure out the correct load order for you, and inject your dependencies.</p> <p>This is also why you can't freeze your provider tables - this prevents Oh My Prvd from modifying them, thus preventing dependency injection.</p>"},{"location":"reference/core/providers/use/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/use/#provider-providert","title":"provider <code>: Provider&lt;T&gt;</code>","text":"<p>The provider to use.</p>"},{"location":"reference/core/providers/use/#returns-t","title":"Returns <code>: T</code>","text":"<p>The used provider. In reality, this returns a shadow of the provider, which will be injected during startup.</p>"},{"location":"reference/core/providers/use/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"reference/core/types/","title":"Index","text":"Reference Core"},{"location":"reference/core/types/#types","title":"Types","text":"<p>Types exported by the core Prvd 'M Wrong package.</p> <ul> <li> Lifecycle</li> <li> OnInit</li> <li> OnStart</li> <li> Options</li> <li> Provider</li> </ul>"},{"location":"reference/core/types/lifecycle/","title":"Lifecycle","text":"Prvd 'M Wrong Core Types type since v0.2"},{"location":"reference/core/types/lifecycle/#lifecycle","title":"Lifecycle","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/types/on-init/","title":"OnInit","text":"Prvd 'M Wrong Core Types type since v0.2"},{"location":"reference/core/types/on-init/#oninit","title":"OnInit","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/types/on-start/","title":"OnStart","text":"Prvd 'M Wrong Core Types type since v0.2"},{"location":"reference/core/types/on-start/#onstart","title":"OnStart","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/types/options/","title":"Options","text":"Prvd 'M Wrong Core type since v0.1"},{"location":"reference/core/types/options/#options","title":"Options","text":"<p>Configures how Prvd 'M Wrong will ignite. The following are the available configuration options: This type is not useful outside of Prvd 'M Wrong itself; prefer to specify startup options as a parameter of <code>ignite(options)</code>.</p> LuauTypeScript <pre><code>export type Options = {\n  logLevel: \"none\" | \"verbose\",\n  profiling: boolean\n}\n</code></pre> <pre><code>export type Options = {\n  logLevel: \"none\" | \"verbose\"\n  profiling: boolean\n}\n</code></pre>"},{"location":"reference/core/types/options/#members","title":"Members","text":""},{"location":"reference/core/types/options/#loglevel-none-verbose","title":"logLevel <code>: \"none\" | \"verbose\"</code>","text":"<p>Configures if Prvd 'M Wrong should log trace information to the console, defaults to <code>\"none\"</code>.</p>"},{"location":"reference/core/types/options/#profiling-boolean","title":"profiling <code>: boolean</code>","text":"<p>Configures if built-in lifecycle events should be profiled with <code>debug.setmemorycategory</code> and <code>debug.profilebegin</code>, defaults to whether the current session is running in Roblox Studio.</p>"},{"location":"reference/core/types/options/#learn-more","title":"Learn More","text":"<ul> <li>startup tutorial</li> </ul>"},{"location":"reference/core/types/provider/","title":"Provider","text":"Prvd 'M Wrong Core type since v0.1"},{"location":"reference/core/types/provider/#provider","title":"Provider","text":"<p>Provides a specific functionality for a game. This type is not useful outside of Prvd 'M Wrong itself; prefer to use <code>use(provider)</code> for more precise types.</p> LuauTypeScript <pre><code>export type Provider&lt;T&gt; = T &amp; {\n  loadOrder: number?,\n  onInit: ((self: Provider&lt;T&gt;) -&gt; Promise?)?,\n  onStart: (self: Provider&lt;T&gt;) -&gt; ()?\n}\n</code></pre> <pre><code>export type Provider&lt;T extends object&gt; = T &amp; {\n  loadOrder?: number,\n  onInit?(): void | Promise&lt;void&gt;,\n  onStart?(): void\n}\n</code></pre>"},{"location":"reference/core/types/provider/#members","title":"Members","text":""},{"location":"reference/core/types/provider/#loadorder-number","title":"loadOrder <code>: number</code>","text":"<p>Determines when to initialize the provider. Defaults to one. This member is not generally useful, as Prvd 'M Wrong will figure out a load order with dependency injection.</p>"},{"location":"reference/core/types/provider/#oninit-self-providert-promise","title":"onInit <code>: (self: Provider&lt;T&gt;) -&gt; Promise?</code>","text":"<p>Runs sequentially before any other lifecycle methods, methods are expected to be infallible and preferably non-yielding.</p> <p>If it returns a promise, Prvd 'M Wrong will await for the promise to resolve.</p>"},{"location":"reference/core/types/provider/#onstart-self-providert-","title":"onStart <code>: (self: Provider&lt;T&gt;) -&gt; ()</code>","text":"<p>Runs concurrently after all other lifecycle methods have been registered. This means failures and yields do not affect other providers.</p>"},{"location":"reference/core/types/provider/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"reference/lifecycles/players/","title":"Index","text":"Reference Lifecycles"},{"location":"reference/lifecycles/players/#players","title":"Players","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/players/on-player-added/","title":"OnPlayerAdded","text":"Reference Lifecycles Players"},{"location":"reference/lifecycles/players/on-player-added/#onplayeradded","title":"onPlayerAdded","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/players/on-player-removed/","title":"OnPlayerRemoved","text":"Reference Lifecycles Players"},{"location":"reference/lifecycles/players/on-player-removed/#onplayerremoved","title":"onPlayerRemoved","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/","title":"Index","text":"Reference Runtime"},{"location":"reference/lifecycles/runtime/#runtime","title":"Runtime","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/on-post-simulation/","title":"OnPostSimulation","text":"Reference Lifecycles Runtime"},{"location":"reference/lifecycles/runtime/on-post-simulation/#onplayeradded","title":"onPlayerAdded","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/on-pre-render/","title":"OnPreRender","text":"Reference Lifecycles Runtime"},{"location":"reference/lifecycles/runtime/on-pre-render/#onprerender","title":"onPreRender","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/on-pre-simulation/","title":"OnPreSimulation","text":"Reference Lifecycles Runtime"},{"location":"reference/lifecycles/runtime/on-pre-simulation/#onpresimulation","title":"onPreSimulation","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/on-shutdown/","title":"OnShutdown","text":"Reference Lifecycles Runtime"},{"location":"reference/lifecycles/runtime/on-shutdown/#onshutdown","title":"onShutdown","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/","title":"Get Started","text":"<p>Congratulations on choosing Prvd 'M Wrong! You're finally making good choices.</p> <p>Prvd 'M Wrong is a service provider framework for a next-generation Roblox. Here, you will learn how to build great games with Prvd 'M Wrong, even if you're a complete newcomer to the library.</p> <p>But first, something important...</p> <p> Do not use Prvd 'M Wrong in production unless you're really, really, really, REALLY, really willing and able to withstand large, sweeping changes. </p> <p>Yes, that was five-reallys important.</p> <p>Prvd 'M Wrong is in very early alpha right now! You will encounter:</p> <ul> <li>nonexistent or broken features</li> <li>changes in how things work between versions</li> <li>updates that completely remove existing features</li> <li>evolving recommendations on conventions and project structure</li> </ul> <p>This is not a bad thing! It means we can quickly abandon counterproductive ideas and features, and build a solid foundation for the future.</p> <p>Don't be discouraged though, feel free to follow along with our development and try using the library in your own time. We hope you enjoy using Oh My Prvd!</p>"},{"location":"tutorials/#expectations","title":"Expectations","text":"<p>These tutorials assume:</p> <ul> <li>That you're comfortable with Roblox and the Luau scripting language.<ul> <li>These tutorials are not an introduction to Luau \u2013 If you'd like to learn,     see the Roblox creator documentation.</li> </ul> </li> <li>That - if you're using Roblox TypeScript - you're comfortable with TypeScript.<ul> <li>These tutorials are not an introduction to TypeScript - If you'd like     to learn, see Roblox TypeScript's documentation     and the TypeScript handbook</li> <li>These tutorials also assume you're familiar with Luau, which especially     is important when troubleshooting bugs \u2013 If you'd like to learn, see the     Roblox creator documentation.</li> </ul> </li> </ul> <p>Some tutorials might challenge you more than others. Remember, Prvd 'M Wrong is built with you in mind, but it may still take a bit of time to absorb some concepts. Take your time and explore at your own pace.</p>"},{"location":"tutorials/#support","title":"Support","text":"<p>Should you be struggling to understand a concept, or need help debugging an error, here are some resources which can help.</p>"},{"location":"tutorials/#support-with-errors","title":"Support with Errors","text":"<p>Prvd 'M Wrong attaches a link with every console log message. These links direct you to our comprehensive Error Messages documentation.</p> <pre><code>[PMW(requireAfterIgnition)]: cannot require other providers after startup\n  more info: prvdmwrong.github.io/prvdmwrong/latest/reference/general/error-messages#requireafterignition\n  stack trace:\n    prvdmwrong.log:118 function throw\n    prvdmwrong.prvd:181 function use\n    Main:42\n</code></pre> <p>It explains the meaning of each message, its origin within Prvd 'M Wrong, and relevant context. When you run into an error, that page is a great place to start!</p>"},{"location":"tutorials/#additional-support","title":"Additional Support","text":"<p>Prvd 'M Wrong is built with you in mind and our documentation aims to be as useful and comprehensive as possible. However, you might need specific advice on an issue, perhaps you may want to learn Prvd 'M Wrong through other means, or you caught a showstopper bug.</p> <p>Whatever you're looking for, feel free to swing by our dedicated thread over the Roblox OSS Discord server. Maintainers drop in frequently alongside eager Prvd 'M Wrong users.</p>"},{"location":"tutorials/installation/","title":"Installation","text":"<p>Prvd 'M Wrong is broken down into functional packages, which you will need to import into your game. This page will walk you through installing a package.</p>"},{"location":"tutorials/installation/#templates","title":"Templates","text":"<p>For new projects, Prvd 'M Wrong has batteries-included templates to be used.</p> <p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/installation/#manual-installation","title":"Manual Installation","text":"<p>For existing projects, Prvd 'M Wrong must be imported as individual packages.</p>"},{"location":"tutorials/installation/#install-via-roblox","title":"Install via Roblox","text":"<p>If you edit directly inside Roblox Studio, then you can import a Roblox model file containing Prvd 'M Wrong.</p> <ol> <li>Head over to Prvd 'M Wrong's \"Releases\" page.</li> <li>Find the package you will install, if you are just following the tutorials,   you can install the <code>prvdmwrong</code> core package.</li> <li>Click the \"Assets\" dropdown to view the downloadable files:    </li> <li>Click on the package you would like to import, which should end in <code>.rbxm</code>:    </li> <li>Open Roblox Studio to import the model. If you are just following the   tutorials, just an empty baseplate will do.</li> <li>Right-click on <code>ReplicatedStorage</code>, and select \"Insert from File\":    </li> <li>You should see an <code>prvdmwrong</code> module script appear in ReplicatedStorage!</li> </ol>"},{"location":"tutorials/installation/#install-via-wallypesde","title":"Install via Wally/Pesde","text":"<p>If you use Wally or Pesde for Luau, Prvd 'M Wrong has packages for both package managers.</p> WallyPesde <ol> <li> <p>Head over to one of these packages you will import:</p> <ul> <li><code>@prvdmwrong/core</code>     for the core package</li> <li><code>@prvdmwrong/lifecycles</code>     for additional lifecycle methods</li> </ul> </li> <li> <p>Copy the metadata below \"Install\", and append it below <code>[dependencies]</code> in your <code>wally.toml</code>:</p> <p></p> <p>It will look like below, with the core package aliased to <code>prvd</code> for brevity:</p> <pre><code>[dependencies]\n  prvd = \"prvdmwrong/core@0.2.0\"\n</code></pre> </li> <li> <p>Then, install your packages:</p> <pre><code>$ wally install\n</code></pre> <p>This will install Prvd 'M Wrong under the\u00a0<code>Packages</code>\u00a0directory, which is usually located in <code>ReplicatedStorage</code>:</p> <pre><code>local prvd = require(ReplicatedStorage.Packages.prvd)\n</code></pre> </li> <li> <p>If you'd want the linker modules to also export types, you can use the     Wally Package Types     tool:</p> <pre><code>$ wally-package-types --sourcemap sourcemap.json Packages/\n</code></pre> </li> </ol> <ol> <li> <p>Head over to one of these packages you will import:</p> <ul> <li><code>@prvdmwrong/core</code>     for the core package</li> <li><code>@prvdmwrong/lifecycles</code>     for additional lifecycle methods</li> </ul> </li> <li> <p>Run the command below \"Installation\", which will look like below:</p> <pre><code>$ pesde add prvdmwrong/lifecycles@0.2.0-dev.8\n</code></pre> </li> </ol>"},{"location":"tutorials/installation/#install-via-npm","title":"Install via NPM","text":"<p>If you use Roblox TypeScript, Prvd 'M Wrong has type definitions and packages for NPM.</p> <ol> <li> <p>Head over to one of these packages you will import:</p> <ul> <li><code>@prvdmwrong/core</code>     for the core package</li> <li><code>@prvdmwrong/lifecycles</code>     for additional lifecycle methods</li> </ul> </li> <li> <p>Copy the command below \"Install\", and run it on a terminal:</p> <p></p> </li> <li> <p>Roblox TypeScript does not include Prvd 'M Wrong. Find the following     JSON in your project file, it may be nested behind several levels:</p> <pre><code>\"node_modules\": {\n  \"@rbxts\": {\n    \"$path\": \"node_modules/@rbxts\"\n  }\n}\n</code></pre> <p>Add the <code>@prvdmwrong</code> scope next to <code>@rbxts</code>:</p> <pre><code>\"node_modules\": {\n  \"@rbxts\": {\n    \"$path\": \"node_modules/@rbxts\"\n  },\n  \"@prvdmwrong\": {\n    \"$path\": \"node_modules/@prvdmwrong\"\n  }\n}\n</code></pre> </li> <li> <p>Prvd' M Wrong can imported directly:</p> <pre><code>import prvdmwrong from \"@prvdmwrong/core\"\n</code></pre> </li> </ol>"},{"location":"tutorials/installation/#install-via-source","title":"Install via Source","text":"<p>If you are synchronizing external files into Roblox Studio, Prvd 'M Wrong can be imported as source code.</p> <ol> <li>Head over to Prvd 'M Wrong's 'Releases' page.</li> <li>Click the \"Assets\" dropdown to view the downloadable files:    </li> <li>Under \"Assets\", download <code>Source code (zip)</code>. Inside is a copy of the Oh My   Prvd GitHub repository.:    </li> <li>Inside the zip, open <code>packages</code>, then the package you'd like to import,   and copy it's <code>lib</code> folder; it may be inside another folder.</li> <li>Create a new folder inside your project named \"prvdmwrong\", place it wherever   you keep your libraries.</li> <li>For example, you might paste it inside a\u00a0<code>shared</code>\u00a0or\u00a0a <code>packages</code>\u00a0folder.</li> <li>Paste the contents of the <code>lib</code> folder into the newly created folder.</li> </ol>"},{"location":"tutorials/installation/#testing","title":"Testing","text":"<p>Now, you can create a script for testing:</p> <ol> <li>Create a <code>Script</code> under <code>ServerScriptService</code>.</li> <li> <p>Remove the following code, and paste this in. Tweak the require/import    to point at <code>prvdmwrong</code> depending on your installation:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.prvdmwrong)\n</code></pre> <pre><code>import prvdmwrong from \"@rbxts/prvdmwrong\"\n</code></pre> </li> <li> <p>Playtest your game - if there are no errors, everything was set up correctly!</p> </li> </ol> My script didn't work! <p><pre><code>prvdmwrong is not a valid member of ReplicatedStorage \"ReplicatedStorage\"\n</code></pre> If you're seeing this error, then your script can't find Prvd 'M Wrong.</p> <p>This code assumes you've placed Prvd 'M Wrong under ReplicatedStorage. If you've installed both elsewhere, you'll need to the <code>require()</code>\u00a0to point towards the correct location.</p> <p>If both looks like it points to the correct location, refer back to\u00a0the previous section\u00a0and double-check you've set everything up properly. Make sure under ReplicatedStorage, there's a ModuleScript named <code>prvdmwrong</code>.</p>"},{"location":"tutorials/advanced/execution-order/","title":"Execution Order","text":"<p>Prvd 'M Wrong initializes providers following a predefined execution order outlined below.</p> <p>Libraries that interacts with Prvd 'M Wrong should understand the exact sequence in which providers are initialized, ensuring correct functionality and prevent potential conflicts or unexpected behaviors.</p> <pre><code>flowchart TB\n    providers_created--&gt;start\n    providers_created{{\"`\n        **Providers created**\n        prvd() @Provider()\n    `\"}}\n    subgraph start[\"`\n        **Startup**\n        prvd.start()\n    `\"]\n        use_dependencies[\"`\n            **Dependencies used**\n            prvd.use()\n        `\"]\n        lifecycles_registered[\"`\n            **Lifecycles registered**\n            prvd.Lifecycle()\n        `\"]\n        lifecycles_on_init[\"`\n            **Providers initialized**\n            MyProvider:onInit()\n        `\"]\n        lifecycles_on_start[\"`\n            **Providers started**\n            MyProvider:onStart()\n        `\"]\n        on_start[\"`\n            **Callbacks spawned**\n            prvd.onStart()\n        `\"]\n        await_start[\"`\n            **Threads spawned**\n            prvd.awaitStart()\n        `\"]\n\n        use_dependencies--&gt;lifecycles_registered\n        lifecycles_registered--&gt;lifecycles_on_init\n        lifecycles_on_init--&gt;lifecycles_on_start\n        lifecycles_on_start--&gt;on_start\n        lifecycles_on_start--&gt;await_start\n    end</code></pre>"},{"location":"tutorials/advanced/execution-order/#prior-to-startup","title":"Prior to Startup","text":"<p>Providers are registered through <code>prvd()</code> for Luau and <code>@Provider()</code> for TypeScript. Providers must be created prior to startup, or Prvd 'M Wrong will throw an error.</p> <p>Lifecycle objects must be created prior to startup for providers to register it. It's recommended to register a lifecycle object inside a provider module.</p>"},{"location":"tutorials/advanced/execution-order/#startup","title":"Startup","text":"<p><code>prvd.start()</code> instantiates the startup procedure. After it has been called, no more providers will be registered and existing providers will not register newer lifecycle objects.</p> <p>Prvd 'M Wrong will first resolve all dependencies. Providers with <code>use()</code>d dependencies will have it injected. Prvd 'M Wrong will topologically sort providers so dependents run after dependencies.</p> <p>Afterwards, all providers will register itself to all appropriate lifecycle objects. The initialization and start lifecycles are registered beforehand.</p> <p>Providers that implement the <code>onInit</code> lifecycle will be initialized sequentially based on the topological sort done earlier. <code>onInit</code> methods are expected to never throw, and preferably non-yielding. Use this stage to set up a provider.</p> <p>Once initialization is complete, providers that implement the <code>onStart</code> lifecycle will be started concurrently regardless of order. As all providers have been initialized, it is safe to use other providers. Finally, all callbacks queued with <code>onStart()</code> and all threads from <code>awaitStart()</code> are spawned.</p>"},{"location":"tutorials/advanced/migration/","title":"Migrating to Prvd 'M Wrong","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/advanced/migration/#knit","title":"Knit","text":""},{"location":"tutorials/advanced/migration/#lumin-framework","title":"Lumin Framework","text":""},{"location":"tutorials/advanced/migration/#proton","title":"Proton","text":""},{"location":"tutorials/advanced/modding/","title":"Modding","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/advanced/philosophies/","title":"Philosophies","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/advanced/philosophies/#alternatives","title":"Alternatives","text":"<p>Prvd 'M Wrong is not the first Roblox service provider framework. There are several existing game frameworks for Roblox. Besides Prvd 'M Wrong, you might consider:</p> <ul> <li>Knit by sleitnick</li> <li>Flamework by fireboltofdeath</li> <li>Nevermore by Quenty</li> <li>Proton by sleitnick</li> <li>Pronghorn by Iron Stag Games</li> <li>Lazy Modules by NightLapse Studios</li> <li>Lumin Framework by Lumin Labs</li> </ul> <p>So, why did we make Prvd 'M Wrong?</p> <p>Each of these frameworks solve the same problem in multiple angles. The goal of Prvd 'M Wrong is to take all of the lessons and ideas learned from these projects and build a framework that can solve this problem for good. In addition, all of these frameworks have major drawbacks:</p> <ul> <li>Knit is unmaintained, it introduces a hefty level of bloat and has subpar   types;</li> <li>Flamework requires TypeScript and is tightly coupled with its transformer;</li> <li>Nevermore introduces an outrageous level of bloat and also harder to use,   being geared primarily just for Quenty;</li> <li>Proton is under development and requires TypeScript, practically unmaintained;</li> <li>Pronghorn does not implement dependency injection, minimal extensibility and   introduces some bloat;</li> <li>Lazy Modules has subpar syntax, somewhat couples code;</li> <li>Lumin Framework provides minimal primitives for singletons in the form of   controllers, does not implement dependency injection;</li> </ul> <p>Finally:</p> <ul> <li>We think a framework should be distributed as a single module, for decoupling   and extensibility.</li> <li>We think a framework should be designed for both Luau and TypeScript, e.g.   Luau and TypeScript providers can be used simultaneously.</li> <li>We think the conventions promoted by other frameworks (e.g. splitting between   services and controllers) are sub-optimal.</li> <li>We have a good enough understanding of the problem to develop something   robust.</li> <li>We think Prvd 'M Wrong should be able to do more than just connect providers.</li> </ul> <p>This is not to say Prvd 'M Wrong is superior, at least not yet:</p> <ul> <li>Components and networking packages are under development, an external   networking/component library is required with Prvd 'M Wrong</li> <li>We strive to keep Prvd 'M Wrong bug-free, but there are blemishes and   imperfection, and is not as battle-tested as other frameworks</li> </ul>"},{"location":"tutorials/advanced/snippets/","title":"Code Snippets","text":"<p>Prvd 'M Wrong is designed to be featherlight, requiring no transformers, compilers, plugins, or extensions. Instead, you may enjoy code snippets to speed up development within Prvd 'M Wrong.</p> <p>All code snippets showcased are made for Luau and TypeScript and found under <code>.vscode</code> in the Prvd 'M Wrong monorepo.</p> <p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/advanced/snippets/#provider","title":"Provider","text":"<p>Constructs and returns a provider that implements the <code>onInit</code> and <code>onStart</code> lifecycles.</p> SnippetOutput <pre><code>// Luau\n\"Provider\": {\n  \"prefix\": \"provider\",\n  \"body\": [\n    \"local ${0:$TM_FILENAME_BASE} = {}\",\n    \"type Self = typeof(${0:$TM_FILENAME_BASE})\",\n    \"\",\n    \"function ${0:$TM_FILENAME_BASE}.onInit(self: Self)\",\n    \"\",\n    \"end\",\n    \"\",\n    \"function ${0:$TM_FILENAME_BASE}.onStart(self: Self)\",\n    \"\",\n    \"end\",\n    \"\",\n    \"return prvd(\\\"${0:$TM_FILENAME_BASE}\\\", ${0:$TM_FILENAME_BASE})\"\n  ],\n  \"description\": \"Create a new Luau provider\"\n}\n</code></pre> <pre><code>// TypeScript\n\"Provider\": {\n  \"prefix\": \"provider\",\n  \"body\": [\n    \"import { Provider, type OnInit, type OnStart } from \\\"@rbxts/prvdmwrong\\\"\",\n    \"\",\n    \"@Provider()\",\n    \"export class ${0:$TM_FILENAME_BASE} implements OnInit, OnStart {\",\n    \"  onInit(): void {\",\n    \"\",\n    \"  }\",\n    \"\",\n    \"  onStart(): void {\",\n    \"\",\n    \"  }\",\n    \"}\"\n  ],\n  \"description\": \"Create a new TypeScript provider\"\n}\n</code></pre> <pre><code>-- Luau\nlocal MyProvider = {}\ntype Self = typeof(MyProvider)\n\nfunction MyProvider.onInit(self: Self)\n\nend\n\nfunction MyProvider.onStart(self: Self)\n\nend\n\nreturn prvd(MyProvider)\n</code></pre> <pre><code>// TypeScript\nimport { Provider, type OnInit, type OnStart } from \"@rbxts/prvdmwrong\"\n\n@Provider()\nexport class MyProvider implements OnInit, OnStart {\n  onInit(): void {\n\n  }\n\n  onStart(): void {\n\n  }\n}\n</code></pre>"},{"location":"tutorials/components/","title":"Components","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/attributes/","title":"Attributes","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/inheritance/","title":"Inheritance","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/usage/","title":"Usage","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/fundamentals/lifecycles/","title":"Lifecycles","text":"<p>Prvd 'M Wrong comes with the <code>:onInit()</code> and <code>:onStart()</code> lifecycles. To tailor your needs, custom lifecycles can be implemented or imported.</p>"},{"location":"tutorials/fundamentals/lifecycles/#implement-your-own","title":"Implement Your Own","text":"<p>You can implement your own lifecycle method. For this example, we will create our own <code>:onPlayerAdded(player)</code> lifecycle method through the <code>Lifecycle</code> object.</p> <p>To use <code>Lifecycle</code> in your code, you first need to import it from the core package, so that you can refer to it by name:</p> LuauTypeScript <pre><code>local Lifecycle = prvd.Lifecycle\ntype Lifecycle&lt;Interface&gt; = prvd.Lifecycle&lt;Interface&gt;\n</code></pre> <pre><code>import { Lifecycle, type Lifecycle } from \"@rbxts/prvdmwrong\"\n</code></pre> <p>Let's define an interface that will sastify our lifecycle:</p> LuauTypeScript <pre><code>type OnPlayerAdded = {\n  onPlayerAdded: (self: unknown, Player) -&gt; ()\n}\n</code></pre> <pre><code>interface OnPlayerAdded {\n  onPlayerAdded(player: Player) =&gt; void\n}\n</code></pre> <p>To create a new lifecycle object, call the <code>Lifecycle</code> object and give it a method to track and a method to call when fired. It takes a parameter and a variadic; for the first part of the tutorial, this will be unnamed:</p> LuauTypeScript <pre><code>local playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", function(_, ...)\n\nend)\n</code></pre> <pre><code>const playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", (_, _) =&gt; {\n\n})\n</code></pre> <p>To fire the lifecycle, call it's <code>:fire(...)</code> method, and pass arguments to call its lifecycle method with:</p> LuauTypeScript <pre><code>Players.PlayerAdded:Connect(function(newPlayer)\n  playerAdded:fire(newPlayer)\nend)\nfor _, existingPlayer in ipairs(Players:GetPlayers()) do\n  playerAdded:fire(existingPlayer)\nend\n</code></pre> <pre><code>Players.PlayerAdded.Connect((newPlayer) =&gt; {\n  playerAdded.fire(newPlayer)\n})\nfor (const existingPlayer of Players:GetPlayers()) {\n  playerAdded.fire(existingPlayer)\n}\n</code></pre> <p>Under the hood, Prvd 'M Wrong will register all providers that specify an <code>onPlayerAdded</code> method.</p>"},{"location":"tutorials/fundamentals/lifecycles/#firing-the-lifecycle","title":"Firing The Lifecycle","text":"<p>Our lifecycle does nothing when we fire it. The lifecycle constructor passes itself as the first argument, to which you can access it's listeners:</p> LuauTypeScript <pre><code>local playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", function(self, ...)\n  for _, listener in ipairs(self.listeners) do\n    task.spawn(listener.onPlayerAdded, listener)\n  end\nend)\n</code></pre> <pre><code>const playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", (lifecycle, _) =&gt; {\n  for (const listener of lifecycle.listeners) {\n    task.spawn(() -&gt; listener.onPlayerAdded)\n  }\n})\n</code></pre> <p>The variadic argument are the arguments passed when the lifecycle is fired. Try asking for a <code>player</code> argument for this handler:</p> LuauTypeScript <pre><code>local playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", function(self, player)\n  for _, listener in ipairs(self.listeners) do\n    task.spawn(listener.onPlayerAdded, listener, player)\n  end\nend)\n</code></pre> <pre><code>const playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", (lifecycle, ...args) =&gt; {\n  for (const listener of lifecycle.listeners) {\n    task.spawn(() -&gt; listener.onPlayerAdded(args[0]))\n  }\n})\n</code></pre> <p>Now, when a player joins the game, the lifecycle fires its listeners:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.prvdmwrong)\n\nlocal MyProvider = {}\nfunction MyProvider:onPlayerAdded(player)\n  print(\"Greetings\", player)\nend\n\nreturn prvd.new(\"MyProvider\", MyProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/prvdmwrong\"\nexport const MyProvider = Provider(\"MyProvider\", {\n  onPlayerAdded(player) {\n    print(\"Greetings\", player)\n  }\n})\n</code></pre> <p>The PointsProvider from earlier can be rewritten to use it:</p> LuauTypeScript <pre><code>-- ...\n\nfunction PointsProvider.onStart(self: Self)\n  Players.PlayerRemoving:Connect(function(player)\n    self.points[player] = nil\n  end)\nend\n\nfunction PointsProvider.onPlayerAdded(self: Self, newPlayer: Player)\n  self:setDefaultPoints(newPlayer)\nend\n\n-- ...\n</code></pre> <pre><code>export const PointsProvider = Provider(\"PointsProvider\", {\n  // ...\n  onStart() {\n    Players.PlayerRemoving.Connect((player) =&gt; {\n      this.points.delete(player)\n    })\n  }\n\n  onPlayerAdded(newPlayer: Player) {\n    this.setDefaultPoints(newPlayer)\n  }\n  // ...\n})\n</code></pre>"},{"location":"tutorials/fundamentals/lifecycles/#preset-handlers","title":"Preset Handlers","text":"<p>For convenience, Prvd 'M Wrong exports two handlers you can use while constructing lifecycles.</p> <p>For lifecycles that do not depend on execution order, you can pass <code>fireConcurrent</code> as the <code>fire</code> method. This will spawn all of the lifecycle listeners as threads:</p> LuauTypeScript <pre><code>local fireConcurrent = prvd.fireConcurrent\nlocal playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", fireConcurrent)\n</code></pre> <pre><code>import { Lifecycle, fireConcurrent } from \"@rbxts/prvdmwrong\"\nconst playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", fireConcurrent)\n</code></pre> <p>Contrast to <code>fireConcurrent</code>, for lifecycles that do depend on execution order, you can pass <code>fireSequential</code> as the <code>fire</code> method. This will run all of the lifecycle listeners synchronously:</p> LuauTypeScript <pre><code>local fireSequential = prvd.fireSequential\nlocal playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", fireSequential)\n</code></pre> <pre><code>import { Lifecycle, fireSequential } from \"@rbxts/prvdmwrong\"\nconst playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", fireSequential)\n</code></pre> <p>Exercise error safety</p> <p><code>fireSequential</code> does not protect itself from errors. If a listener throws an error in its lifecycle method, it will halt further execution.</p> <p>Instead, write a handler that is protected from errors:</p> LuauTypeScript <pre><code>local playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", function(self, player)\n  for _, listener in ipairs(self.listeners) do\n    local ok, result = pcall(listener.onPlayerAdded, listener, player)\n    if ok == false then\n      warn(listener, \"threw an error!\", result)\n    end\n  end\nend)\n</code></pre> <pre><code>const playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", (lifecycle, player) =&gt; {\n  for (const listener of lifecycle.listeners) {\n    const [ok, result] = pcall(() =&gt; listener.onPlayerAdded(player))\n    if (ok == false) {\n      warn(listener, \"threw an error!\", result)\n    }\n  }\n})\n</code></pre>"},{"location":"tutorials/fundamentals/lifecycles/#additional-lifecycles","title":"Additional Lifecycles","text":"<p>Creating additional lifecycle methods such as <code>:onPlayerAdded(player)</code> can be a hassle. For this, Prvd 'M Wrong exports additional lifecycle methods through a separate <code>prvdmwrong-lifecycles</code> package, which you will have to install.</p> <p>Once installed, import the package, preferably within your startup script:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nrequire(ReplicatedStorage.Packages.ohmyprvdLifecycles)\n</code></pre> <pre><code>import \"@rbxts/prvdmwrong-lifecycles\"\n</code></pre> <p>This package exports nothing. Instead, it registers a separate provider that implements a host of lifecycle events during runtime:</p> <ul> <li><code>:onPostSimulation(dt)</code>, <code>:onPreSimulation(dt)</code>, and <code>:onPreRender(dt)</code> lets you   hook onto RunService's runtime events:<ul> <li><code>:onPostSimulation(dt)</code> runs every <code>RunService.PostSimulation</code> and is     optimal for responding to changes in the physics state.</li> <li><code>:onPreSimulation(dt)</code> runs every <code>RunService.PreSimulation</code> and is     optimal for manipulating physics.</li> <li><code>:onPreRender(dt)</code> runs every <code>RunService.PreRender</code>. Notably, this only     runs on the client.</li> </ul> </li> <li><code>:onShutdown</code> hooks onto <code>game:BindToClose</code>, or <code>plugin.Unloading</code> if ran   under a plugin environment. <code>:onShutdown</code> also cleanups built-in lifecycle   methods, preventing memory leaks especially for a plugin. It's great for doing   post-mortem cleanup once the game closes or your plugin is unloaded.</li> <li><code>:onPlayerAdded(player)</code> and <code>:onPlayerRemoving(player)</code> binds to   Players.PlayerAdded and Players.PlayerRemoving respectively, making it ideal   for tracking players.</li> </ul>"},{"location":"tutorials/fundamentals/providers/","title":"Providers","text":"<p>Prvd 'M Wrong allows you to define providers for your game logic. These provide specific functions within your game, e.g. you might create a <code>SaveDataProvider</code> to manage save files or a <code>CameraProvider</code> to handle player camera movement.</p>"},{"location":"tutorials/fundamentals/providers/#structure","title":"Structure","text":"<p>This is the minimum structure of a provider, which can be used and hook onto lifecycle events:</p> LuauTypeScript <pre><code>local prvd = -- Import Prvd 'M Wrong however you'd like!\n\nlocal PointsProvider = {}\nreturn prvd(PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/prvdmwrong\"\n\n@Provider()\nexport class Provider {}\n</code></pre> <p>Beware the difference</p> <p>Both <code>prvd</code> and <code>@Provider()</code> appeal for different environments. <code>prvd()</code> is used as a function to construct Luau providers. Contrast to <code>@Provider()</code>, which is used as a class decorator to construct TypeScript decorators.</p> <p>For Luau providers, a <code>name</code> property can be specified which will be used for memory profiling, and falls back to the current script running. Names are inferred for TypeScript providers.</p> <pre><code>local PointsProvider = {}\nPointsProvider.name = \"PointsProvider\"\n</code></pre> <p>Notice that you're creating the provider at the bottom of a file, and then returning it. This lets Prvd 'M Wrong to strictly type your provider, something which will be important later.</p>"},{"location":"tutorials/fundamentals/providers/#methods-properties-the-likes","title":"Methods, Properties, The Likes","text":"<p>Providers are just tables at the end of the day. As such, it's easy to add methods, properties, and the likes to providers.</p> <p>Let's add a <code>points</code> property to our <code>PointsProvider</code>, which will be a map of a <code>Player</code> and their points:</p> LuauTypeScript <pre><code>local prvd = -- Import Prvd 'M Wrong however you'd like!\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal PointsProvider = {}\nPointsProvider.name = \"PointsProvider\"\nPointsProvider.points = {}\n\nreturn prvd(PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/prvdmwrong\"\n\n@Provider()\nexport class Provider {\n  public readonly points = new Map&lt;Player, number&gt;()\n}\n</code></pre> <p>To instantiate our <code>points</code>, let's also implement a <code>setDefaultPoints</code> method for convenience:</p> LuauTypeScript <pre><code>local prvd = -- Import Prvd 'M Wrong however you'd like!\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal PointsProvider = {}\nPointsProvider.name = \"PointsProvider\"\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider),\n  player: Player\n)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/prvdmwrong\"\n\n@Provider()\nexport class Provider {\n  public readonly points = new Map&lt;Player, number&gt;()\n\n  setDefaultPoints(player: Player) {\n    this.points.set(player, 10)\n  }\n}\n</code></pre> <p>Take a step back, and review what we wrote.</p> <p>Notice in our <code>setDefaultPoints</code>, we require the first argument to be <code>self</code>, which is <code>typeof</code> our <code>PointsProvider</code>.</p> <p>This allows Luau to provide useful type information. Notice how if we omit the <code>self</code> argument and use a colon <code>:</code> for our method, we lose typings for <code>self</code>:</p> <pre><code>function PointsProvider:setDefaultPoints(\n  player: Player\n)\n  -- self.points is typed as `a`, which is not very helpful!\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n</code></pre> <p>Contrast as to if we typed <code>self</code> as a parameter:</p> <pre><code>function PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider),\n  player: Player\n)\n  -- Now, self.points is helpfully typed as `{ [Player]: number }`!\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n</code></pre> <p><code>typeof(PointsProvider)</code> is not very concise. Let's make a type alias, appropriately named <code>Self</code>:</p> <pre><code>-- use just typeof()...\ntype Self = typeof(PointsProvider)\n-- ...or wrap it inside prvd.Provider\ntype Self = prvd.Provider&lt;typeof(PointsProvider)&gt;\n</code></pre> <p>Both types are good, pick your poison and run with it.</p> <p>We could then easily type <code>self</code> as such:</p> <pre><code>function PointsProvider.setDefaultPoints(self: Self, player: Player)\n</code></pre> <p>Now, our code can use <code>self</code> as a shorthand for the <code>PointsProvider</code>, while other snippets of code could use our method through one of the following:</p> <pre><code>-- pass self directly as an argument...\nPointsProvider.setDefaultPoints(PointsProvider, player)\n-- ...or let Luau pass self for us!\nPointsProvider:setDefaultPoints(player)\n</code></pre>"},{"location":"tutorials/fundamentals/providers/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>Providers and the likes can implement lifecycle methods, by having a method that matches its lifecycle name.</p> <p>Prvd 'M Wrong provides two lifecycles out of the box. <code>onInit</code> runs sequentially before any other lifecycle methods, methods are expected to be infallible and preferably non-yielding.</p> <p>In contrast, <code>onStart</code> runs concurrently after all other lifecycle methods have been registered. This means failures and yields do not affect other providers.</p> <p>Let's implement the <code>onStart</code> lifecycle, where we will set default points for every player that joins:</p> LuauTypeScript <pre><code>local prvd = -- Import Prvd 'M Wrong however you'd like!\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal PointsProvider = {}\ntype Self = typeof(PointsProvider)\nPointsProvider.name = \"PointsProvider\"\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(self: Self, player: Player)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nfunction PointsProvider.onStart(self: Self)\n  Players.PlayerAdded:Connect(function(newPlayer)\n    self:setDefaultPoints(newPlayer)\n  end)\n  for _, existingPlayer in pairs(Players:GetPlayers()) do\n    self:setDefaultPoints(existingPlayer)\n  end\nend\n\nreturn prvd(PointsProvider)\n</code></pre> <pre><code>import { Provider, type OnStart } from \"@rbxts/prvdmwrong\"\nimport { Players } from \"@rbxts/services\"\n\n@Provider()\nexport class Provider implements OnStart {\n  public readonly points = new Map&lt;Player, number&gt;()\n\n  setDefaultPoints(player: Player) {\n    this.points.set(player, 10)\n  }\n\n  onStart() {\n    Players.PlayerAdded.Connect((newPlayer) =&gt; {\n      this.setDefaultPoints(newPlayer)\n    })\n    for (const existingPlayer in Players.GetPlayers()) {\n      this.setDefaultPoints(existingPlayer)\n    }\n  }\n}\n</code></pre>"},{"location":"tutorials/fundamentals/providers/#memory","title":"Memory","text":"<p>Now we have a problem: theres a memory leak.</p> <p>When we set points for a player, we add the player to the table. What happens when the player leaves? Nothing. Which is an issue.</p> <p>That player's data is forever held onto within the <code>points</code> table. We need to clear out that data when the player leaves. Let's hook up our <code>onStart</code> lifecycle with the <code>Players.PlayerRemoving</code> event and remove a players points:</p> LuauTypeScript <pre><code>local prvd = -- Import Prvd 'M Wrong however you'd like!\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal PointsProvider = {}\ntype Self = typeof(PointsProvider)\nPointsProvider.name = \"PointsProvider\"\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(self: Self, player: Player)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nfunction PointsProvider.onStart(self: Self)\n  Players.PlayerAdded:Connect(function(newPlayer)\n    self:setDefaultPoints(newPlayer)\n  end)\n  for _, existingPlayer in pairs(Players:GetPlayers()) do\n    self:setDefaultPoints(existingPlayer)\n  end\n  Players.PlayerRemoving:Connect(function(player)\n    self.points[player] = nil\n  end)\nend\n\nreturn prvd(PointsProvider)\n</code></pre> <pre><code>import { Provider, type OnStart } from \"@rbxts/prvdmwrong\"\nimport { Players } from \"@rbxts/services\"\n\n@Provider()\nexport class Provider implements OnStart {\n  readonly points = new Map&lt;Player, number&gt;()\n\n  setDefaultPoints(player: Player) {\n    this.points.set(player, 10)\n  }\n\n  onStart() {\n    Players.PlayerAdded.Connect((newPlayer) =&gt; {\n      this.setDefaultPoints(newPlayer)\n    })\n    for (const existingPlayer in Players.GetPlayers()) {\n      this.setDefaultPoints(existingPlayer)\n    }\n    Players.PlayerRemoving.Connect((newPlayer) =&gt; {\n      this.points.delete(newPlayer)\n    })\n  }\n}\n</code></pre>"},{"location":"tutorials/fundamentals/providers/#dependencies","title":"Dependencies","text":"<p>Often, providers may depend on other providers, such as a <code>CombatProvider</code> requiring the player's <code>CharacterProvider</code>. Prvd 'M Wrong lets you use providers through dependency injection.</p> <p>First, create a file for a new <code>MathProvider</code> with the following:</p> LuauTypeScript <pre><code>local prvd = -- Import Prvd 'M Wrong however you'd like!\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal MathProvider = {}\n\nfunction MathProvider:add(a: number, b: number): number\n  -- this method is very expensive! takes a lot of time!\n  task.wait(5)\n  return a + b\nend\n\nreturn prvd(MathProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/prvdmwrong\"\n\n@Provider()\nexport class MathProvider {\n  add(a: number, b: number) {\n    // this method is very expensive! takes a lot of time!\n    task.wait(5)\n    return a + b\n  }\n}\n</code></pre> <p>Then, from <code>PointsProvider</code>, import your newly created <code>MathProvider</code>:</p> LuaTypeScript <pre><code>-- Tweak this based on where you placed the MathProvider\nlocal MathProvider = require(script.Parent.MathProvider)\n</code></pre> <pre><code>// Tweak this based on where you placed the MathProvider\nimport { MathProvider } from \"./math-provider\"\n</code></pre> <p>Finally, just specify your provider <code>use()</code>s another provider:</p> LuauTypeScript <pre><code>local prvd = -- Import Prvd 'M Wrong however you'd like!\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\n-- Tweak this based on where you placed the MathProvider\nlocal MathProvider = require(script.Parent.MathProvider)\n\nlocal PointsProvider = {}\ntype Self = typeof(PointsProvider)\nPointsProvider.name = \"PointsProvider\"\nPointsProvider.points = {}\nPointsProvider.mathProvider = prvd.use(PointsProvider)\n\nfunction PointsProvider.setDefaultPoints(self: Self, player: Player)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nfunction PointsProvider.onStart(self: Self)\n  Players.PlayerAdded:Connect(function(newPlayer)\n    self:setDefaultPoints(newPlayer)\n  end)\n  for _, existingPlayer in pairs(Players:GetPlayers()) do\n    self:setDefaultPoints(existingPlayer)\n  end\n  Players.PlayerRemoving:Connect(function(player)\n    self.points[player] = nil\n  end)\nend\n\nfunction PointsProvider.addPoints(self: Self, player: Player, amount: number)\n  local currentPoints = self.points[player]\n  local newPoints = self.mathProvider.add(currentPoints, amount)\n  self.points[player] = newPoints\nend\n\nreturn prvd(PointsProvider)\n</code></pre> <pre><code>import { Provider, use, type OnStart } from \"@rbxts/prvdmwrong\"\nimport { Players } from \"@rbxts/services\"\n\n// Tweak this based on where you placed the MathProvider\nimport { MathProvider } from \"./math-provider\"\n\n@Provider()\nexport class Provider implements OnStart {\n  readonly points = new Map&lt;Player, number&gt;()\n  mathProvider = use(MathProvider)\n\n  setDefaultPoints(player: Player) {\n    this.points.set(player, 10)\n  }\n\n  onStart() {\n    Players.PlayerAdded.Connect((newPlayer) =&gt; {\n      this.setDefaultPoints(newPlayer)\n    })\n    for (const existingPlayer in Players.GetPlayers()) {\n      this.setDefaultPoints(existingPlayer)\n    }\n    Players.PlayerRemoving.Connect((newPlayer) =&gt; {\n      this.points.delete(newPlayer)\n    })\n  }\n\n  add(player: Player, amount: number) {\n    const currentPoints = this.points.get(player)\n    const newPoints = this.mathProvider.add(currentPoints, amount)\n    this.points.set(player, newPoints)\n  }\n}\n</code></pre> <p>Do not use dependencies outside of lifecycle methods!</p> <p>Prvd 'M Wrong only returns a shadow of the <code>use()</code>-d provider. You cannot use it outside of lifecycle methods.</p> <p>Behind the scenes, Prvd 'M Wrong will keep track of what dependencies your provider uses, figure out the correct load order for you, and inject your dependencies.</p> <p>This is also why you can't freeze your provider tables - this prevents Prvd 'M Wrong from modifying them.</p>"},{"location":"tutorials/fundamentals/providers/#congratulations","title":"Congratulations","text":"<p>You just successfully wrote your first provider using Prvd 'M Wrong!</p> <p>That was a taste of Prvd 'M Wrong. Later on, you will learn how to register your own lifecycle methods, use Prvd 'M Wrong networking primitives, and creating your own components.</p> <p>You can find the completed modules for MathProvider and PointsProvider in the <code>examples</code> directory.</p> <p>Once you're comfortable writing providers, you are ready to take on the rest of what Prvd 'M Wrong offers.</p>"},{"location":"tutorials/fundamentals/startup/","title":"Startup","text":"<p>With your providers defined, its time to start Prvd 'M Wrong.</p>"},{"location":"tutorials/fundamentals/startup/#preloading","title":"Preloading","text":"<p>It's necessary to preload your providers to for Prvd 'M Wrong to pick it up. For convenience, you can use the <code>prvd.preload(instances, predicate)</code> function, which will load all modules given an array of instances:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.prvdmwrong)\n\nprvd.preload(script.Providers:GetChildren())\n</code></pre> <pre><code>import { preload } from \"@rbxts/prvdmwrong\"\npreload(script.Providers.GetChildren())\n</code></pre> <p>You can also pass a predicate function to filter the target modules:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.prvdmwrong)\n\nprvd.preload(\n  script.Providers:GetChildren(),\n  function(module: ModuleScript)\n    return module.Name:find(\"Provider$\") ~= nil\n  end\n)\n</code></pre> <pre><code>import { preload } from \"@rbxts/prvdmwrong\"\npreload(\n  script.Providers.GetChildren(),\n  (module) =&gt; module.Name.find(\"Provider$\") !== undefined\n)\n</code></pre>"},{"location":"tutorials/fundamentals/startup/#startup_1","title":"Startup","text":"<p>Finally, start Prvd 'M Wrong, and you're off to the races:</p> <pre><code>prvd.start()\n</code></pre> <p>If another script requires Prvd 'M Wrong to be ignited, <code>awaitStart()</code> can be used, which will yield until Prvd 'M Wrong is fully ignited:</p> <pre><code>prvd.awaitStart()\n</code></pre> <p>Alternatively, if you need to bind to startup, <code>onStart(callback)</code> can be used, which will spawn the callback when Prvd 'M Wrong has fully ignited:</p> LuauTypeScript <pre><code>prvd.onStart(function()\n  print(\"ignited!\")\nend)\n</code></pre> <pre><code>onStart(() =&gt; {\n  print(\"ignited!\")\n})\n</code></pre>"},{"location":"tutorials/net/","title":"Net","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/events/","title":"Events","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/functions/","title":"Functions","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/middlewares/","title":"Middlewares","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/namespaces/","title":"Namespaces","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"}]}