{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"LuauTypeScript <pre><code>local prvd = require(\"@pkg/ohmyprvd\")\nlocal CalculusProvider = require(\"./calculus-provider\")\n\nlocal MathProvider = {}\nMathProvider.calculusProvider = prvd.use(CalculusProvider)\n\nfunction MathProvider.add(self: typeof(MathProvider), a: number, b: number)\n  return self.calculusProvider.add(a, b)\nend\n\nreturn prvd.Provider(\"MathProvider\", MathProvider)\n</code></pre> <pre><code>import { Provider, use } from \"@rbxts/ohmyprvd\"\nimport CalculusProvider from \"./calculus-provider\"\n\nexport const MathProvider = Provider(\"MathProvider\", {\n  calculusProvider = use(CalculusProvider)\n\n  add(a: number, b: number) {\n    return this.CalculusProvider.add(a, b)\n  }\n})\nexport = MathProvider\n</code></pre>   Scroll down for a quick look at the three main highlights"},{"location":"#the-roblox-developerssecret-weapon","title":"The Roblox Developer'sSecret Weapon","text":"<p> Oh My Prvd is a delightful framework for modern Roblox game development. </p> <p> Oh My Prvd accelerates the process with providers, connecting the top-level design of your game. Choose to mix in networking and components as you need. Enjoy a development experience that fades into the background, freeing you to build faster and shout: </p> <p>\"Oh, My Prvd!\"</p> <p>Get Started \u00b7 Download \u00b7  Batteries included</p>"},{"location":"#providers","title":"Providers","text":"<p>Oh My Prvd introduces providers for your game logic. These provide specific functions within your game, e.g. you might create a <code>SaveDataProvider</code> to manage save files or a <code>CameraProvider</code> to handle player camera movement.</p> <p>Create providers to handle the top level logic of your game:</p> LuauTypeScript <pre><code>local CoinsProvider = {}\nreturn prvd.new(\"CoinsProvider\", CoinsProvider)\n</code></pre> <pre><code>@Provider({})\nexport class CoinsProvider {}\n</code></pre> <p>At the end of the day, providers are just plain tables. It's easy to implement more methods, properties, and the likes into a provider:</p> LuauTypeScript <pre><code>local CoinsProvider = {}\ntype Self = typeof(CoinsProvider)\nCoinsProvider.balance = {}\n\nfunction CoinsProvider.addCoins(self: Self, player: Player, coins: number)\n  self.coins[person] += coins\nend\n\nreturn prvd.new(\"CoinsProvider\", CoinsProvider)\n</code></pre> <pre><code>@Provider({})\nexport class CoinsProvider {\n  balance: Map&lt;Player, number&gt; = {},\n\n  addCoins(player: Player, coins: number) {\n    this.coins[person] += coins\n  }\n})\n</code></pre> <p>Providers can <code>use()</code> other providers. Oh My Prvd will provide its types and figure out a corresponding load order for you:</p> LuauTypeScript <pre><code>local RewardsProvider = {}\ntype Self = typeof(CoinsProvider)\nRewardsProvider.coinsProvider = prvd.use(CoinsProvider)\n\nfunction RewardsProvider.addWinRewards(self: Self, player: Player)\n  self.coinsProvider:addCoins(player, 30)\nend\n\nreturn prvd.new(\"RewardsProvider\", RewardsProvider)\n</code></pre> <pre><code>@Provider({})\nexport class RewardsProvider {\n  coinsProvider = use(CoinsProvider)\n\n  addCoins(person: Player) {\n    this.coinsProvider:addCoins(player, coins)\n  }\n}\n</code></pre> <p>Finally, preload your providers, then start Oh My Prvd, and you're off to the races:</p> LuauTypeScript <pre><code>prvd.preload(ServerScriptService.Providers:GetDescendants())\nprvd.start(options)\n</code></pre> <pre><code>preload(ServerScriptService.Providers.GetDescendants())\nstart(options)\n</code></pre>"},{"location":"#mixins","title":"Mixins","text":""},{"location":"#extensible","title":"Extensible","text":"<p>Oh My Prvd brings comprehensive APIs for extending the framework. Here's one of the common ones, <code>Lifecycle</code> to implement your own lifecycle methods:</p> LuauTypeScript <pre><code>-- this interface satisfies our method\ntype OnCharacterAdded = {\n  onCharacterAdded(self: unknown, character: Model) -&gt; ()\n}\n\n-- `fireConcurrent` is a built-in lifecycle handler that spawns listeners\nlocal characterAdded = Lifecycle(\"onCharacterAdded\", fireConcurrent)\n\n-- now fire the lifecycle method!\nif (LocalPlayer.Character) then\n  characterAdded:fire(LocalPlayer.Character)\nend\nLocalPlayer.CharacterAdded:Connect(function(character)\n  characterAdded:fire(character)\nend)\n</code></pre> <pre><code>// this interface satisfies our method\ninterface OnCharacterAdded {\n  onCharacterAdded(character: Model): void\n}\n\n// `fireConcurrent` is a built-in lifecycle handler that spawns listeners\nconst characterAdded = Lifecycle(\"onCharacterAdded\", fireConcurrent)\n\n// now fire the lifecycle method!\nif (LocalPlayer.Character) {\n  characterAdded.fire(LocalPlayer.Character)\n}\nLocalPlayer.CharacterAdded.Connect((character) =&gt; {\n  characterAdded.fire(character)\n})\n</code></pre> <p>A provider can then hook onto the lifecycle:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal CombatProvider = {}\nfunction CombatProvider:onCharacterAdded(character: Model)\n  local rootPart: BasePart = assert(character:FindFirstChild(\"HumanoidRootPart\"))\n  -- do something with rootPart\nend\n\nreturn prvd.new(CombatProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\n\n@Provider({})\nexport class CombatProvider implements OnCharacterAdded {\n  onCharacterAdded(character) {\n    const rootPart: BasePart = assert(character:FindFirstChild(\"HumanoidRootPart\"))\n    // do something with rootPart\n  }\n}\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Welcome to the Examples section! Here, you can find various open-source implementations to see Oh My Prvd used in a real setting, accompanied with in-depth explanations.</p>"},{"location":"examples/#open-source-projects","title":"Open-Source Projects","text":""},{"location":"examples/#oh-my-prvd-obby-for-oh-my-prvd-01","title":"Oh My Prvd Obby (for Oh My Prvd 0.1)","text":"<p>  Read the explanation  Play on Roblox  Source code on GitHub</p> <p>See how Oh My Prvd can be used to build a simple obby, decked with a JToH-esque client objects provider, a checkpoints provider, a networking provider, and a debug provider.</p>"},{"location":"examples/projects/omp-obby/","title":"Oh My Prvd Obby","text":""},{"location":"examples/projects/omp-obby/#oh-my-prvd-obby","title":"Oh My Prvd Obby","text":"<p>See how Oh My Prvd can be used to build a simple obby, decked with a JToH-esque client objects provider, a checkpoints provider, a networking provider, and a debug provider.</p> <p>  Play on Roblox  Source code on GitHub</p>"},{"location":"examples/projects/omp-obby/#explanation","title":"Explanation","text":"<p>This game serves as a feature complete example of the core Oh My Prvd package. It serves as motivation for creating other games using the core package, utilizing a partially managed Rojo configuration to leverage Roblox Studio as a visual representation and external editors for code editing.</p> <p>Some games, for example obbies, might contain lots of different client objects, e.g. spinners, damage bricks, and jump pads to name a few.</p> <p>Some of these client objects can be done with basic constraints, e.g. a spinner can be made with a CylindricalConstraint and some attachments, while a damage brick would need a remote event to damage the player.</p> <p>For more complex client objects, it would be ergonomic to use ModuleScripts and run it with a corresponding client object, which perhaps will have the CollectionService \"Objects\" tag and a \"Script\" string attribute to specify the ObjectScript to use. Let's call these <code>ObjectScript</code>s, which will satisfy this type:</p> <pre><code>export type ObjectScript = {\n  type: \"ObjectScript\",\n  runner: (\n    self: ObjectScript,\n    object: Instance,\n    scope: { unknown }\n  ) -&gt; (),\n}\n</code></pre> <p>The <code>ObjectScript</code> interface will use a table for future extensions, such as specifying it's own type guards, or enable some feature flags.</p> <p>Note the <code>ObjectScript:runner(object, scope)</code> method, which receives both the target object and a scope, which will be cleaned up once the client object unloads.</p> <p>Let's create <code>ObjectProvider</code>s for the server and the client. During startup, the server <code>ObjectProvider</code> moves objects from the workspace to the ServerStorage. This then uses the <code>NetProvider</code> and connects to the <code>GetObjects</code> remote, using the <code>PlayerProvider</code> to validate if a player has client objects. If not, the <code>ObjectProvider</code> sends a clone of the client objects to the player.</p> <p>The players <code>ObjectProvider</code> will wait for the client objects to appear as a child of the player. Then, every object with the CollectionService tag \"Objects\" and a \"Script\" string attribute gets processed, with a corresponding <code>ObjectScript</code>. It will prepare a runner thread, link the object and its script to it, and then enables it.</p> <p>Checkpoints are kept separate from client objects to be tracked by the <code>PlayerProvider</code>s alongside with session info. The <code>PlayerProvider</code> tracks all players and assigns each some <code>PlayerSession</code> information, which satisfies this type:</p> <pre><code>export type PlayerSession = {\n  checkpoint: number,\n  hasObjects: boolean,\n\n  startedAt: number,\n  leaderstats: Folder &amp; {\n    Stage: IntValue,\n    Time: IntValue,\n  },\n}\n</code></pre> <p>The <code>PlayerProvider</code> increments a player <code>PlayerSession.checkpoint</code> once the player touches the next consecutive checkpoint. This also uses the <code>NetProvider</code> to fire the <code>NextCheckpoint</code> event, which is picked up by the players <code>GuiProvider</code> to create some confetti.</p> <p>The <code>ObjectsProvider</code> sets a player <code>PlayerSession.hasObjects</code> to true once it sends the client objects to prevent a player from firing the <code>GetObjects</code> event several times.</p> <p>Finally, the <code>PlayerProvider</code> sets a players <code>PlayerSession.startedAt</code> to <code>os.clock()</code> as soon as the player joined, and increments a players <code>PlayerSession.leaderstats</code> until the player reached the final checkpoint.</p> <p>This game uses some other providers too:</p> <ul> <li>The <code>DebugProvider</code> copies all Tools from its StudioTools folder if the   current session is running on Roblox Studio. It comes with a Noclip tool to   help ease playtesting the obby.</li> <li>The <code>GuiProvider</code> manages the games user interface using Fusion 0.3. Notably,   this provider tracks the <code>NextCheckpoint</code> event to increment a value based on   the players current checkpoint. It then observes that for firing confetti or   toggling a win message.</li> <li>The <code>NetProvider</code> wraps around RemoteEvents and eases using them. It serves as   a replacement for the planned <code>ohmyprvd-net</code> package, which has not been   released. Other providers will use the <code>t</code> package to typecheck remote data.</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This section provides detailed reference documentation for working with Oh My Prvd. For an introduction to Oh My Prvd, see the Learn section.</p> <p>Under construction</p> <p>The reference is under construction - information may be incomplete or missing.</p>"},{"location":"reference/#types","title":"Types","text":"<p>For convenience, API pages will have it's corresponding type member annotated in both Luau and TypeScript:</p> LuauTypeScript <pre><code>function prvd.start(\n  options: {\n    logLevel: \"none\" | \"verbose\" | nil,\n    profiling: boolean?,\n  }?\n): ()\n</code></pre> <pre><code>export const start: (\n  options: Partial&lt;Options&gt; = {\n    logLevel: \"none\",\n    profiling: RunService.IsStudio(),\n  }\n) =&gt; void\n</code></pre> <p>While these type annotations are kept to be accurate, it is ultimately psuedo-code included as developer aid. For fully accurate and syntactically valid type information, please refer to the source code directly.</p>"},{"location":"reference/#conventions","title":"Conventions","text":"<p>The reference uses several conventions, explained below:</p>"},{"location":"reference/#constructors","title":"Constructors","text":"<p>The cube icon is utilized to signify a constructor, a special type of function responsible for creating and initializing objects.</p>"},{"location":"reference/#enumerations","title":"Enumerations","text":"<p>The list icon denotes an enumerations, which represent a set of named constants.</p>"},{"location":"reference/#functions","title":"Functions","text":"<p>The code icon represents a function, a fundamental building block of code that encapsulates a specific task or calculation.</p>"},{"location":"reference/#hooks","title":"Hooks","text":"<p>The branch icon denotes a hook, a special type of function that allows you to \"hook into\" Oh My Prvd to perform side effects.</p>"},{"location":"reference/#types_1","title":"Types","text":"<p>The checklist icon is used to indicate a type, which defines the interface and possible values of an object.</p>"},{"location":"reference/#packages","title":"Packages","text":"<p>The reference is broken down into functional packages.</p>"},{"location":"reference/#core","title":"Core","text":"<p>Details the <code>ohmyprvd</code> package, which implements provider primitives and everything needed to bootstrap a game:</p> <ul> <li>Providers \u00b7 Create and use game providers</li> <li>Lifecycles \u00b7 Create lifecycle methods and events</li> <li>Modding \u00b7 Extend Oh My Prvd's core functionality</li> <li>Internal \u00b7 Lower level primitives for library   authors</li> <li>Types \u00b7 Types exported by the core package</li> </ul>"},{"location":"reference/#lifecycles","title":"Lifecycles","text":"<p>Details the <code>ohmyprvd-lifecycles</code> package, which implements a \"small\" amount of lifecycle events.</p> <ul> <li>Runtime \u00b7 Lifecycle methods for the Roblox   runtime</li> <li>Players \u00b7 Lifecycle methods for the Players   service</li> </ul>"},{"location":"reference/#net","title":"Net","text":"<p>Details the <code>ohmyprvd-net</code> package, which implements networking primitives for providers.</p> Unreleased <p>This package is unreleased, as such no documentation is available at this time.</p>"},{"location":"reference/#components","title":"Components","text":"<p>Details the <code>ohmyprvd-components</code> package, which implements a component system for providers.</p> Unreleased <p>This package is unreleased, as such no documentation is available at this time.</p>"},{"location":"reference/#debugger","title":"Debugger","text":"<p>Details the <code>ohmyprvd-debugger</code> package, which implements a quality of life debugger for working with Oh My Prvd.</p> Unreleased <p>This package is unreleased, as such no documentation is available at this time.</p>"},{"location":"reference/error-messages/","title":"Error Messages","text":"Reference"},{"location":"reference/error-messages/#error-messages","title":"Error Messages","text":"<p>Oh My Prvd attaches an error ID with every console log message. This is used to uniquely identify what kind of error or message you're seeing.</p> <p>For example, given the message below, the error ID would be <code>usedBeforeIgnition</code>.</p> <pre><code>[OMP(usedBeforeIgnition)]: cannot use provider \"MyProvider\" prior to startup\n</code></pre> <p>Use the search box below to paste in or type an error ID, and it will scroll to the details for you.</p> <p></p>"},{"location":"reference/error-messages/#alreadystarted","title":"alreadyStarted","text":"<pre><code>cannot start more than once\n</code></pre> <p>Thrown by: <code>prvd.start(options)</code></p> <p>You attempted to start Oh My Prvd when it has already started.</p>"},{"location":"reference/error-messages/#cannotregister","title":"cannotRegister","text":"<pre><code>cannot register provider; `MyProvider.onStart` should be a function\n</code></pre> <p>Thrown by: <code>prvd.Provider</code>, <code>prvd.new</code></p> <p>You attempted to register a new provider, but Oh My Prvd caught something wrong. The error includes a more specific message which can be used to diagnose the issue. Typically it is one of the following:</p> <ul> <li>A provider of the same name was already registered</li> <li>You have frozen the provider table, which prevents dependency injection</li> <li>You provided a mismatched type for a built-in method/property</li> <li>You forgot to include a non-empty string as a <code>name</code></li> </ul>"},{"location":"reference/error-messages/#cannotusenonprovider","title":"cannotUseNonProvider","text":"<pre><code>`use()` must be given a provider\n</code></pre> <p>Thrown by: <code>prvd.use</code></p> <p>You attempted to <code>use()</code> an object that was not registered as a provider.</p>"},{"location":"reference/error-messages/#invalidloadparent","title":"invalidLoadParent","text":"<p>Thrown by: <code>prvd.preload</code></p> <pre><code>preload must be given an instance\n</code></pre> <p><code>prvd.preload(instances, predicate)</code> expected you to give it a parent instance to load from, but you gave it something else.</p>"},{"location":"reference/error-messages/#invalidonignitioncallback","title":"invalidOnIgnitionCallback","text":"<pre><code>`onStart` must be given callbacks\n</code></pre> <p>Thrown by: <code>prvd.onStart</code></p> <p><code>prvd.onStart(callback)</code> expected you to give it a callback to spawn after startup finishes, but you gave it something else.</p>"},{"location":"reference/error-messages/#registerafterignition","title":"registerAfterIgnition","text":"<pre><code>cannot register providers after startup\n</code></pre> <p>Thrown by: <code>prvd.Provider</code>, <code>prvd.new</code></p> <p>You attempted to register a provider after startup.</p> <p>Make sure you've preloaded all providers you will use prior to startup, and that no other module registers a provider after startup.</p>"},{"location":"reference/error-messages/#oniniterror","title":"onInitError","text":"<p>Thrown by: <code>prvd.start</code></p> <pre><code>cannot initialize MyProvider; attempted to index nil with 'property'\n</code></pre> <p>Oh My Prvd could not finish its initialization lifecycle as a provider threw an error in it's <code>:init</code> method. The error includes a more specific message which can be used to diagnose the issue.</p>"},{"location":"reference/error-messages/#requireerror","title":"requireError","text":"<pre><code>cannot require ServerScriptService.Providers.MyProvider; Module code did not return exactly one value\n</code></pre> <p>Thrown by: <code>prvd.preload</code>,</p> <p><code>prvd.preload(instances, predicate)</code> loaded a module which threw an error that Oh My Prvd cannot handle. The error includes a more specific message which can be used to diagnose the issue.</p>"},{"location":"reference/error-messages/#unknown","title":"unknown","text":"<pre><code>unknown error: attempt to call a nil value\nhelp: this indicates oh my prvd isn't reporting errors correctly, please file an issue\n</code></pre> <p>Oh My Prvd ran into an error, but cannot associate it with an error message. This is a fallback error type which shouldn't be seen by end users, because it indicates that Oh My Prvd is not reporting errors correctly.</p>"},{"location":"reference/error-messages/#useafterstartup","title":"useAfterStartup","text":"<pre><code>cannot use other providers after startup\n</code></pre> <p>Thrown by: <code>prvd.use</code></p> <p>You tried to <code>use()</code> another provider after Oh My Prvd started.</p> <p>Make sure every provider explicitly <code>use()</code>s all providers it needs. This lets Oh My Prvd figure out a corresponding load order.</p>"},{"location":"reference/error-messages/#usedbeforestartup","title":"usedBeforeStartup","text":"<pre><code>cannot use provider \"MyProvider\" prior to startup\nhelp: ohmyprvd will inject the dependency for you during runtime, its safe to use the provider inside a lifecycle method\n</code></pre> <p>You tried to access the contents of a <code>use()</code>d provider prior to startup.</p> <p>Oh My Prvd will inject the dependency for you when ignited and figure out a corresponding load order. Make sure when you use another provider, you're using it from a lifecycle method.</p>"},{"location":"reference/core/","title":"Index","text":"Reference"},{"location":"reference/core/#core","title":"Core","text":"<p>This package contains fundamental primitives for creating and using game providers. Contains everything needed to bootstrap a Roblox game and utilities for extending the core Oh My Prvd package.</p> <p>Install this through your preferred package manager:</p> WallyNPMPNPMYarn <pre><code>ohmyprvd = \"znotfireman/ohmyprvd@0.2.0-dev.3\"\n</code></pre> <pre><code>npm i @rbxts/ohmyprvd\n</code></pre> <pre><code>pnpm i @rbxts/ohmyprvd\n</code></pre> <pre><code>yarn add @rbxts/ohmyprvd\n</code></pre>"},{"location":"reference/core/#providers","title":"Providers","text":"<ul> <li> Provider</li> <li> StartupStatus</li> <li> preload</li> <li> start</li> <li> use</li> <li> awaitStart</li> <li> onStart</li> </ul>"},{"location":"reference/core/#types","title":"Types","text":"<ul> <li> Lifecycle</li> <li> OnInit</li> <li> OnStart</li> <li> Options</li> <li> Provider</li> </ul>"},{"location":"reference/core/#lifecycles","title":"Lifecycles","text":"<ul> <li> Lifecycle</li> <li> fireConcurrent</li> <li> fireSequential</li> <li> onLifecycleRegistered</li> <li> onLifecycleUnregistered</li> </ul>"},{"location":"reference/core/#modding","title":"Modding","text":"<ul> <li> getStartupOptions</li> <li> getStartupStatus</li> <li> onProviderConstructed</li> <li> onProviderUsed</li> </ul>"},{"location":"reference/core/#internal","title":"Internal","text":"<ul> <li> defineMetadata</li> <li> deleteMetadata</li> <li> getMetadata</li> <li> registerAll</li> <li> registerDependency</li> <li> registerMethod</li> <li> unregisterMethod</li> </ul>"},{"location":"reference/core/internal/","title":"Index","text":"Reference Core"},{"location":"reference/core/internal/#internal","title":"Internal","text":"<p>Lower level primitives for library authors.</p> <p>Beware</p> <p>These are internal APIs are made for library authors. Do not touch this unless you know what you're doing, unless you'd like to be fired.</p>"},{"location":"reference/core/internal/#members","title":"Members","text":"<ul> <li> defineMetadata</li> <li> deleteMetadata</li> <li> getMetadata</li> <li> registerAll</li> <li> registerDependency</li> <li> registerMethod</li> <li> unregisterMethod</li> </ul>"},{"location":"reference/core/internal/define-metadata/","title":"defineMetadata","text":"Reference Core Internal function since v0.1"},{"location":"reference/core/internal/define-metadata/#definemetadata","title":"defineMetadata","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> LuauTypeScript <pre><code>function prvd.defineMetadata(\n  object: unknown,\n  key: string,\n  value: unknown,\n): ()\n</code></pre> <pre><code>export const defineMetadata: (\n  object: unknown,\n  key: string,\n  value: unknown,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/internal/define-metadata/#parameters","title":"Parameters","text":""},{"location":"reference/core/internal/define-metadata/#object-unknown","title":"object <code>: unknown</code>","text":""},{"location":"reference/core/internal/define-metadata/#key-string","title":"key <code>: string</code>","text":""},{"location":"reference/core/internal/define-metadata/#value-unknown","title":"value <code>: unknown</code>","text":""},{"location":"reference/core/internal/delete-metadata/","title":"deleteMetadata","text":"Reference Core Internal function since v0.1"},{"location":"reference/core/internal/delete-metadata/#deletemetadata","title":"deleteMetadata","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> LuauTypeScript <pre><code>function prvd.deleteMetadata(\n  object: unknown,\n  key: string,\n): ()\n</code></pre> <pre><code>export const deleteMetadata: (\n  object: unknown,\n  key: string,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/internal/delete-metadata/#parameters","title":"Parameters","text":""},{"location":"reference/core/internal/delete-metadata/#object-unknown","title":"object <code>: unknown</code>","text":""},{"location":"reference/core/internal/delete-metadata/#key-string","title":"key <code>: string</code>","text":""},{"location":"reference/core/internal/get-metadata/","title":"getMetadata","text":"Reference Core Internal function since v0.1"},{"location":"reference/core/internal/get-metadata/#getmetadata","title":"getMetadata","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> LuauTypeScript <pre><code>function prvd.getMetadata(\n  object: unknown,\n  key: string,\n): unknown?\n</code></pre> <pre><code>export const getMetadata: &lt;T&gt;(\n  object: unknown,\n  key: string\n) =&gt; T | undefined\nexport const deleteMetadata: (\n  object: unknown,\n  key: string,\n  property?: string,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/internal/get-metadata/#parameters","title":"Parameters","text":""},{"location":"reference/core/internal/get-metadata/#object-unknown","title":"object <code>: unknown</code>","text":""},{"location":"reference/core/internal/get-metadata/#key-string","title":"key <code>: string</code>","text":""},{"location":"reference/core/internal/get-metadata/#returns","title":"Returns","text":"<p>The metadata value.</p>"},{"location":"reference/core/internal/register-all/","title":"registerAll","text":"Reference Core Internal function since v0.2"},{"location":"reference/core/internal/register-all/#registerall","title":"registerAll","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/internal/register-dependency/","title":"registerDependency","text":"Reference Core Internal function since v0.2"},{"location":"reference/core/internal/register-dependency/#registerdependency","title":"registerDependency","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/internal/register-method/","title":"registerMethod","text":"Reference Core Internal function since v0.2"},{"location":"reference/core/internal/register-method/#registermethod","title":"registerMethod","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/internal/unregister-method/","title":"unregisterMethod","text":"Reference Core Internal function since v0.2"},{"location":"reference/core/internal/unregister-method/#unregistermethod","title":"unregisterMethod","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/lifecycles/","title":"Index","text":"Reference Core"},{"location":"reference/core/lifecycles/#lifecycles","title":"Lifecycles","text":"<p>Primitives for implementing lifecycle methods and events.</p>"},{"location":"reference/core/lifecycles/#members","title":"Members","text":"<ul> <li> Lifecycle \u00b7 Create lifecycle objects</li> <li> fireConcurrent \u00b7 Lifecycle handler   that spawns listeners concurrently</li> <li> fireSequential \u00b7 Lifecycle handler   that runs listeners sequentially</li> <li> onLifecycleRegistered \u00b7   Called when an object registers a lifecycle</li> <li> onLifecycleUnregistered   \u00b7 Called when an object unregisters a lifecycle</li> </ul>"},{"location":"reference/core/lifecycles/fire-concurrent/","title":"fireConcurrent","text":"Reference Core Lifecycles function since v0.2"},{"location":"reference/core/lifecycles/fire-concurrent/#fireconcurrent","title":"fireConcurrent","text":"<p>A function that spawns all listeners of a lifecycle asynchronously. Intended to be used as the <code>fire</code> argument of the lifecycle constructor.</p> LuauTypeScript <pre><code>function prvd.fireConcurrent(\n  self: Lifecycle,\n  ...: unknown\n): ()\n</code></pre> <pre><code>export function fireConcurrent: (\n  lifecycle: Lifecycle,\n  ...args: unknown[]\n) =&gt; void\n</code></pre>"},{"location":"reference/core/lifecycles/fire-concurrent/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/fire-concurrent/#self-lifecycle","title":"self <code>: Lifecycle</code>","text":"<p>The lifecycle object that should have its listeners ran.</p>"},{"location":"reference/core/lifecycles/fire-concurrent/#unknown","title":"... <code>: unknown</code>","text":"<p>Arguments to call the listeners' method.</p>"},{"location":"reference/core/lifecycles/fire-concurrent/#learn-more","title":"Learn More","text":"<ul> <li>Lifecycles tutorial</li> </ul>"},{"location":"reference/core/lifecycles/fire-sequential/","title":"fireSequential","text":"Reference Core Lifecycles function since v0.2"},{"location":"reference/core/lifecycles/fire-sequential/#firesequential","title":"fireSequential","text":"<p>A function that runs all listeners of a lifecycle in order synchronously. Intended to be used as the <code>fire</code> argument of the lifecycle constructor.</p> LuauTypeScript <pre><code>function prvd.fireSequential(\n  self: Lifecycle,\n  ...: unknown\n): ()\n</code></pre> <pre><code>export function fireSequential: (\n  lifecycle: Lifecycle,\n  ...args: unknown[]\n) =&gt; void\n</code></pre>"},{"location":"reference/core/lifecycles/fire-sequential/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/fire-sequential/#self-lifecycle","title":"self <code>: Lifecycle</code>","text":"<p>The lifecycle object that should have its listeners ran.</p>"},{"location":"reference/core/lifecycles/fire-sequential/#unknown","title":"... <code>: unknown</code>","text":"<p>Arguments to call the listeners' method.</p>"},{"location":"reference/core/lifecycles/fire-sequential/#learn-more","title":"Learn More","text":"<ul> <li>Lifecycles tutorial</li> </ul>"},{"location":"reference/core/lifecycles/lifecycle/","title":"Lifecycle","text":"Reference Core Lifecycles constructor since v0.2"},{"location":"reference/core/lifecycles/lifecycle/#lifecycle","title":"Lifecycle","text":"<p>Constructs and returns a new lifecycle within Oh My Prvd. Lifecycles are special event dispatchers that can hook onto a provider's method.</p> LuauTypeScript <pre><code>function prvd.Lifecycle(\n  method: string,\n  fire: (self: Lifecycle, ...unknown) -&gt; ()\n): Lifecycle\n</code></pre> <pre><code>export function Lifecycle: (\n  method: string,\n  fire: (lifecycle: Lifecycle, ...args: unknown[]) =&gt; void\n) =&gt; Lifecycle\n</code></pre>"},{"location":"reference/core/lifecycles/lifecycle/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/lifecycle/#method-string","title":"method <code>: string</code>","text":"<p>The provider method that this lifecycle should hook onto. During startup, Oh My Prvd will register all lifecycles on a provider.</p>"},{"location":"reference/core/lifecycles/lifecycle/#fire-self-lifecycle-unknown-","title":"fire <code>: (self: Lifecycle, ...unknown) -&gt; ()</code>","text":"<p>A method to fire the lifecycle method. It receives itself and the arguments passed to it. For convenience, Oh My Prvd provides two methods you can use:</p> <ul> <li><code>fireConcurrent(self, ...)</code> which spawns all listeners   concurrently</li> <li><code>fireSequential(self, ...)</code> which runs all listeners   sequentially</li> </ul>"},{"location":"reference/core/lifecycles/lifecycle/#returns","title":"Returns","text":"<p>A freshly constructed lifecycle.</p>"},{"location":"reference/core/lifecycles/lifecycle/#learn-more","title":"Learn More","text":"<ul> <li>Lifecycles tutorial</li> </ul>"},{"location":"reference/core/lifecycles/on-lifecycle-registered/","title":"onLifecycleRegistered","text":"Reference Core Lifecycles hook since v0.1"},{"location":"reference/core/lifecycles/on-lifecycle-registered/#onlifecycleregistered","title":"onLifecycleRegistered","text":"<p>Called when an object registers a lifecycle method. Handlers are expected to be infallible and non-yielding. The handler receives the constructed provider.</p> LuauTypeScript <pre><code>function prvd.onLifecycleRegistered(\n  method: string,\n  handler: (Provider&lt;unknown&gt;) -&gt; ()\n): ()\n</code></pre> <pre><code>export const onLifecycleRegistered: (\n  method: string,\n  handler: (provider: Provider&lt;unknown&gt;) =&gt; void\n) =&gt; void\n</code></pre>"},{"location":"reference/core/lifecycles/on-lifecycle-registered/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/on-lifecycle-registered/#method-string","title":"method <code>: string</code>","text":"<p>The method that is registered. During startup, all providers will have its lifecycles registered.</p>"},{"location":"reference/core/lifecycles/on-lifecycle-registered/#handler-providerunknown-void","title":"handler <code>: (Provider&lt;unknown&gt;) -&gt; void</code>","text":"<p>A handler for providers that register the specified method. It receives the provider which implements the method.</p>"},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/","title":"onLifecycleUnregistered","text":"Reference Core Lifecycles hook since v0.1"},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/#onlifecycleunregistered","title":"onLifecycleUnregistered","text":"<p>Called when an object unregisters a lifecycle method. Handlers are expected to be infallible and non-yielding. The handler receives the constructed provider.</p> LuauTypeScript <pre><code>function prvd.onLifecycleUnregistered(\n  method: string,\n  handler: (Provider&lt;unknown&gt;) -&gt; ()\n): ()\n</code></pre> <pre><code>export const onLifecycleUnregistered: (\n  method: string,\n  handler: (provider: Provider&lt;unknown&gt;) =&gt; void\n) =&gt; void\n</code></pre>"},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/#parameters","title":"Parameters","text":""},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/#method-string","title":"method <code>: string</code>","text":"<p>The method that is unregistered.</p>"},{"location":"reference/core/lifecycles/on-lifecycle-unregistered/#handler-providerunknown-void","title":"handler <code>: (Provider&lt;unknown&gt;) -&gt; void</code>","text":"<p>A handler for providers that unregisters the specified method. It receives the provider which unregistered the method.</p>"},{"location":"reference/core/modding/","title":"Index","text":"Reference Core"},{"location":"reference/core/modding/#modding","title":"Modding","text":"<p>Hooks and utilities for extending the core Oh My Prvd package.</p> <p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/modding/get-startup-options/","title":"getStartupOptions","text":"Reference Core Modding function since v0.1"},{"location":"reference/core/modding/get-startup-options/#getignitionoptions","title":"getIgnitionOptions","text":"<p>Returns the startup configuration options. Options are reconciled with default values.</p> LuauTypeScript <pre><code>function prvd.getIgnitionOptions(): Options\n</code></pre> <pre><code>export const getIgnitionOptions: () =&gt; Options\n</code></pre>"},{"location":"reference/core/modding/get-startup-options/#returns","title":"Returns","text":"<p>The startup options, reconciled with default values.</p>"},{"location":"reference/core/modding/get-startup-status/","title":"getStartupStatus","text":"Reference Core Modding"},{"location":"reference/core/modding/get-startup-status/#getstartupstatus","title":"getStartupStatus","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/modding/on-provider-constructed/","title":"onProviderConstructed","text":"Reference Core Modding hook since v0.1"},{"location":"reference/core/modding/on-provider-constructed/#onproviderconstructed","title":"onProviderConstructed","text":"<p>Called just before Oh My Prvd returns a newly constructed provider. Handlers are expected to be infallible and non-yielding. The handler receives the constructed provider.</p> LuauTypeScript <pre><code>function prvd.onProviderConstructed(\n  handler: (Provider&lt;unknown&gt;) -&gt; ()\n) -&gt; (),\n</code></pre> <pre><code>export const onProviderConstructed: (\n  handler: (provider: Provider&lt;object&gt;) =&gt; void,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/modding/on-provider-constructed/#parameters","title":"Parameters","text":""},{"location":"reference/core/modding/on-provider-constructed/#handler-providerunknown-void","title":"handler <code>: (Provider&lt;unknown&gt;) -&gt; void</code>","text":"<p>A handler that is called just before a newly constructed provider is returned. It receives the provider.</p>"},{"location":"reference/core/modding/on-provider-used/","title":"onProviderUsed","text":"Reference Core Modding hook since v0.1"},{"location":"reference/core/modding/on-provider-used/#onproviderused","title":"onProviderUsed","text":"<p>Called just before Oh My Prvd returns a used provider. Handlers are expected to be infallible and non-yielding. The handler receives the used provider.</p> LuauTypeScript <pre><code>function prvd.onProviderUsed(\n  handler: (Provider&lt;unknown&gt;) -&gt; ()\n) -&gt; (),\n</code></pre> <pre><code>export const onProviderUsed: (\n  handler: (provider: Provider&lt;object&gt;) =&gt; void,\n) =&gt; void\n</code></pre>"},{"location":"reference/core/modding/on-provider-used/#parameters","title":"Parameters","text":""},{"location":"reference/core/modding/on-provider-used/#handler-providerunknown-void","title":"handler <code>: (Provider&lt;unknown&gt;) -&gt; void</code>","text":"<p>A handler that is called when a provider has been used. It receives the target provider.</p>"},{"location":"reference/core/providers/","title":"Index","text":"Reference Core"},{"location":"reference/core/providers/#providers","title":"Providers","text":"<p>Fundamental primitives for creating and using game providers.</p>"},{"location":"reference/core/providers/#members","title":"Members","text":"<ul> <li> Provider \u00b7 Construct providers within Oh   My Prvd</li> <li> StartupStatus \u00b7 All startup   phases Oh My Prvd will be in</li> <li> preload \u00b7 Preload an array of ModuleScripts</li> <li> start \u00b7 Starts Oh My Prvd</li> <li> use \u00b7 Use a provider within Oh My Prvd</li> <li> awaitStart \u00b7 Yields until startup   finishes</li> <li> onStart \u00b7 Spawned when startup finishes</li> </ul>"},{"location":"reference/core/providers/await-start/","title":"awaitStart","text":"Reference Core Providers hook since v0.1"},{"location":"reference/core/providers/await-start/#awaitstart","title":"awaitStart","text":"<p>Yields the calling thread just before startup finishes. If Oh My Prvd has already started, the thread will continue.</p> LuauTypeScript <pre><code>function prvd.awaitStart(): ()\n</code></pre> <pre><code>export const awaitStart: () =&gt; void\n</code></pre>"},{"location":"reference/core/providers/await-start/#learn-more","title":"Learn More","text":"<ul> <li>startup tutorial</li> </ul>"},{"location":"reference/core/providers/on-start/","title":"onStart","text":"Reference Core Providers workflow since v0.1"},{"location":"reference/core/providers/on-start/#octicons-hook-16-onstart","title":":octicons-hook-16: onStart","text":"<p>Queues a callback to be called just before startup finishes. If Oh My Prvd has already started, the callback will be spawned immediately.</p> LuauTypeScript <pre><code>function prvd.onStart(\n  callback: () -&gt; ()\n): ()\n</code></pre> <pre><code>export const onStart: (\n  callback: () =&gt; void\n) =&gt; void\n</code></pre>"},{"location":"reference/core/providers/on-start/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/on-start/#callback-","title":"callback <code>: () -&gt; ()</code>","text":"<p>The callback to be spawned just before startup finishes.</p>"},{"location":"reference/core/providers/on-start/#learn-more","title":"Learn More","text":"<ul> <li>startup tutorial</li> </ul>"},{"location":"reference/core/providers/preload/","title":"preload","text":"Reference Core Providers function since v0.1"},{"location":"reference/core/providers/preload/#preload","title":"preload","text":"<p>Preload the specified parent by requiring all <code>ModuleScripts</code> within it. An optional <code>predicate</code> function can be provided to filter modules.</p> LuauTypeScript <pre><code>function prvd.loadChildren(\n  parent: { Instance },\n  predicate: ((ModuleScript) -&gt; boolean)?\n): { unknown }\n</code></pre> <pre><code>export const preload: (\n  parent: Instance[],\n  predicate?: (module: ModuleScript) =&gt; boolean\n) =&gt; unknown[]\n</code></pre>"},{"location":"reference/core/providers/preload/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/preload/#parent-instance","title":"parent <code>: { Instance }</code>","text":"<p>An array of instances to load from. Often paired with <code>:GetChildren()</code> or <code>:GetDescendants()</code>.</p>"},{"location":"reference/core/providers/preload/#predicate-modulescript-boolean","title":"predicate <code>: (ModuleScript) -&gt; boolean</code>","text":"<p>An optional predicate function that will be called to filter the modules to load with.</p>"},{"location":"reference/core/providers/preload/#learn-more","title":"Learn More","text":"<ul> <li>Startup tutorial</li> </ul>"},{"location":"reference/core/providers/provider/","title":"Provider","text":"Reference Core Providers constructor since v0.1"},{"location":"reference/core/providers/provider/#provider","title":"Provider","text":"<p>Constructs and returns a new provider within Oh My Prvd. Providers must be created before calling <code>prvd.start(options)</code>.</p> LuauTypeScript <pre><code>function prvd.Provider&lt;T&gt;(\n  name: string,\n  provider: T\n): Provider&lt;T&gt;\n</code></pre> Too verbose? <p>If writing <code>prvd.Provider</code> sounds verbose for you, Oh My Prvd aliases the <code>Provider</code> constructor with <code>new</code>:</p> <pre><code>local prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nreturn prvd.new(\"PointsProvider\", PointsProvider)\n</code></pre> <p>For consistency, we recommend using <code>Provider</code> when favorable, as <code>new</code> is a reserved keyword in TypeScript.</p> <pre><code>export const Provider: &lt;T extends object&gt;(\n  name: string,\n  provider: T\n) =&gt; Provider&lt;T&gt;\n</code></pre>"},{"location":"reference/core/providers/provider/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/provider/#name-string","title":"name <code>: string</code>","text":"<p>A unique name to identify the provider with. This will be used for debugging.</p>"},{"location":"reference/core/providers/provider/#provider-t","title":"provider <code>: T</code>","text":"<p>The methods and properties of the provider. All lifecycle methods will be registered during startup. The provider may also specify a <code>loadOrder</code> property which dictates when the provider is loaded, and defaults to one.</p>"},{"location":"reference/core/providers/provider/#returns-providert","title":"Returns <code>: Provider&lt;T&gt;</code>","text":"<p>A freshly registered provider.</p>"},{"location":"reference/core/providers/provider/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"reference/core/providers/start/","title":"start","text":"Reference Core Providers function since v0.1"},{"location":"reference/core/providers/start/#start","title":"start","text":"<p>Starts Oh My Prvd. Expected to be called once in an environment, e.g. once on the server and once on the client.</p> <p>All necessary providers should be preloaded before calling this as newly created providers will not run its lifecycle events.</p> LuauTypeScript <pre><code>function prvd.start(\n  options: {\n    logLevel: \"none\" | \"verbose\" | nil,\n    profiling: boolean?,\n  }?\n): ()\n</code></pre> <pre><code>export const start: (\n  options: Partial&lt;Options&gt; = {\n    logLevel: \"none\",\n    profiling: RunService.IsStudio(),\n  }\n) =&gt; void\n</code></pre>"},{"location":"reference/core/providers/start/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/start/#options-partialoptions","title":"options <code>: Partial&lt;Options&gt;</code>","text":"<p>Configures how Oh My Prvd will start. The following are the available configuration options:</p> <ul> <li><code>logLevel: \"none\" | \"verbose\"</code> configures if Oh My Prvd should log trace   information to the console, defaults to none.</li> <li><code>profiling: boolean</code> configures if built-in lifecycle events should be   profiled with <code>debug.setmemorycategory</code> and <code>debug.profilebegin</code>, defaults to   whether the current session is running in Roblox Studio.</li> </ul>"},{"location":"reference/core/providers/start/#learn-more","title":"Learn More","text":"<ul> <li>startup tutorial</li> </ul>"},{"location":"reference/core/providers/startup-status/","title":"StartupStatus","text":"Reference Core Providers enumeration since v0.1"},{"location":"reference/core/providers/startup-status/#startupstatus","title":"StartupStatus","text":"<p>An enumeration of all defined startup status Oh My Prvd will be in.</p> <p>This enum is not useful outside of Oh My Prvd itself; prefer to work with <code>awaitStart()</code> and <code>onStart(callback)</code></p> LuauTypeScript <pre><code>prvd.StartupStatus = {\n  Pending = \"IgnitionStatus.Pending\",\n  startup = \"IgnitionStatus.startup\",\n  Ignited = \"IgnitionStatus.Ignited\"\n}\n</code></pre> <pre><code>export enum StartupStatus {\n  Pending = \"IgnitionStatus.Pending\",\n  startup = \"IgnitionStatus.startup\",\n  Ignited = \"IgnitionStatus.Ignited\"\n}\n</code></pre>"},{"location":"reference/core/providers/startup-status/#items","title":"Items","text":""},{"location":"reference/core/providers/startup-status/#pending-startupstatuspending","title":"Pending <code>: StartupStatus.Pending</code>","text":"<p>Indicates that <code>prvd.start()</code> has not been called yet. Calls to <code>prvd.use()</code> and <code>prvd.Provider()</code> are safe.</p>"},{"location":"reference/core/providers/startup-status/#startup-startupstatusstartup","title":"startup <code>: StartupStatus.startup</code>","text":"<p>Indicates that <code>prvd.start()</code> has been called, but the startup process has not finished. Calls to <code>prvd.use()</code> and <code>prvd.Provider()</code> will throw an error.</p>"},{"location":"reference/core/providers/startup-status/#ignited-startupstatusignited","title":"Ignited <code>: StartupStatus.Ignited</code>","text":"<p>Indicates that the startup process has finished. Calls to <code>prvd.use()</code> and <code>prvd.Provider()</code> will throw an error.</p> <p>Awaiting threads from <code>prvd.awaitStart()</code> and queued callbacks from <code>prvd.onStart()</code> will be spawned just before the startup status is set to this.</p>"},{"location":"reference/core/providers/use/","title":"use","text":"Reference Core Providers function since v0.1"},{"location":"reference/core/providers/use/#use","title":"use","text":"<p>Uses a provider within Oh My Prvd. During startup, Oh My Prvd will inject the dependencies your provider uses.</p> LuauTypeScript <pre><code>function prvd.use&lt;T&gt;(\n  provider: Provider&lt;T&gt;\n): T\n</code></pre> <pre><code>export const use: &lt;T extends object&gt;(\n  provider: Provider&lt;T&gt;\n) =&gt; T\n</code></pre> <p>Do not use dependencies outside of lifecycle methods</p> <p>Oh My Prvd only returns a shadow of the <code>use()</code>d provider. You cannot use it outside of lifecycle methods</p> <p>Behind the scenes, Oh My Prvd will keep track of what dependencies your provider uses, figure out the correct load order for you, and inject your dependencies.</p> <p>This is also why you can't freeze your provider tables - this prevents Oh My Prvd from modifying them, thus preventing dependency injection.</p>"},{"location":"reference/core/providers/use/#parameters","title":"Parameters","text":""},{"location":"reference/core/providers/use/#provider-providert","title":"provider <code>: Provider&lt;T&gt;</code>","text":"<p>The provider to use.</p>"},{"location":"reference/core/providers/use/#returns-t","title":"Returns <code>: T</code>","text":"<p>The used provider. In reality, this returns a shadow of the provider, which will be injected during startup.</p>"},{"location":"reference/core/providers/use/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"reference/core/types/","title":"Index","text":"Reference Core"},{"location":"reference/core/types/#types","title":"Types","text":"<p>Types exported by the core Oh My Prvd package.</p> <ul> <li> Lifecycle</li> <li> OnInit</li> <li> OnStart</li> <li> Options</li> <li> Provider</li> </ul>"},{"location":"reference/core/types/lifecycle/","title":"Lifecycle","text":"Oh My Prvd Core Types type since v0.2"},{"location":"reference/core/types/lifecycle/#lifecycle","title":"Lifecycle","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/types/on-init/","title":"OnInit","text":"Oh My Prvd Core Types type since v0.2"},{"location":"reference/core/types/on-init/#oninit","title":"OnInit","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/types/on-start/","title":"OnStart","text":"Oh My Prvd Core Types type since v0.2"},{"location":"reference/core/types/on-start/#onstart","title":"OnStart","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/core/types/options/","title":"Options","text":"Oh My Prvd Core type since v0.1"},{"location":"reference/core/types/options/#options","title":"Options","text":"<p>Configures how Oh My Prvd will ignite. The following are the available configuration options: This type is not useful outside of Oh My Prvd itself; prefer to specify startup options as a parameter of <code>ignite(options)</code>.</p> LuauTypeScript <pre><code>export type Options = {\n  logLevel: \"none\" | \"verbose\",\n  profiling: boolean\n}\n</code></pre> <pre><code>export type Options = {\n  logLevel: \"none\" | \"verbose\"\n  profiling: boolean\n}\n</code></pre>"},{"location":"reference/core/types/options/#members","title":"Members","text":""},{"location":"reference/core/types/options/#loglevel-none-verbose","title":"logLevel <code>: \"none\" | \"verbose\"</code>","text":"<p>Configures if Oh My Prvd should log trace information to the console, defaults to <code>\"none\"</code>.</p>"},{"location":"reference/core/types/options/#profiling-boolean","title":"profiling <code>: boolean</code>","text":"<p>Configures if built-in lifecycle events should be profiled with <code>debug.setmemorycategory</code> and <code>debug.profilebegin</code>, defaults to whether the current session is running in Roblox Studio.</p>"},{"location":"reference/core/types/options/#learn-more","title":"Learn More","text":"<ul> <li>startup tutorial</li> </ul>"},{"location":"reference/core/types/provider/","title":"Provider","text":"Oh My Prvd Core type since v0.1"},{"location":"reference/core/types/provider/#provider","title":"Provider","text":"<p>Provides a specific functionality for a game. This type is not useful outside of Oh My Prvd itself; prefer to use <code>use(provider)</code> for more precise types.</p> LuauTypeScript <pre><code>export type Provider&lt;T&gt; = T &amp; {\n  loadOrder: number?,\n  onInit: ((self: Provider&lt;T&gt;) -&gt; Promise?)?,\n  onStart: (self: Provider&lt;T&gt;) -&gt; ()?\n}\n</code></pre> <pre><code>export type Provider&lt;T extends object&gt; = T &amp; {\n  loadOrder?: number,\n  onInit?(): void | Promise&lt;void&gt;,\n  onStart?(): void\n}\n</code></pre>"},{"location":"reference/core/types/provider/#members","title":"Members","text":""},{"location":"reference/core/types/provider/#loadorder-number","title":"loadOrder <code>: number</code>","text":"<p>Determines when to initialize the provider. Defaults to one. This member is not generally useful, as Oh My Prvd will figure out a load order with dependency injection.</p>"},{"location":"reference/core/types/provider/#oninit-self-providert-promise","title":"onInit <code>: (self: Provider&lt;T&gt;) -&gt; Promise?</code>","text":"<p>Runs sequentially before any other lifecycle methods, methods are expected to be infallible and preferably non-yielding.</p> <p>If it returns a promise, Oh My Prvd will await for the promise to resolve.</p>"},{"location":"reference/core/types/provider/#onstart-self-providert-","title":"onStart <code>: (self: Provider&lt;T&gt;) -&gt; ()</code>","text":"<p>Runs concurrently after all other lifecycle methods have been registered. This means failures and yields do not affect other providers.</p>"},{"location":"reference/core/types/provider/#learn-more","title":"Learn More","text":"<ul> <li>Providers tutorial</li> </ul>"},{"location":"reference/lifecycles/players/","title":"Index","text":"Reference Lifecycles"},{"location":"reference/lifecycles/players/#players","title":"Players","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/players/on-player-added/","title":"OnPlayerAdded","text":"Reference Lifecycles Players"},{"location":"reference/lifecycles/players/on-player-added/#onplayeradded","title":"onPlayerAdded","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/players/on-player-removed/","title":"OnPlayerRemoved","text":"Reference Lifecycles Players"},{"location":"reference/lifecycles/players/on-player-removed/#onplayerremoved","title":"onPlayerRemoved","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/","title":"Index","text":"Reference Runtime"},{"location":"reference/lifecycles/runtime/#runtime","title":"Runtime","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/on-post-simulation/","title":"OnPostSimulation","text":"Reference Lifecycles Runtime"},{"location":"reference/lifecycles/runtime/on-post-simulation/#onplayeradded","title":"onPlayerAdded","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/on-pre-render/","title":"OnPreRender","text":"Reference Lifecycles Runtime"},{"location":"reference/lifecycles/runtime/on-pre-render/#onprerender","title":"onPreRender","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/on-pre-simulation/","title":"OnPreSimulation","text":"Reference Lifecycles Runtime"},{"location":"reference/lifecycles/runtime/on-pre-simulation/#onpresimulation","title":"onPreSimulation","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"reference/lifecycles/runtime/on-shutdown/","title":"OnShutdown","text":"Reference Lifecycles Runtime"},{"location":"reference/lifecycles/runtime/on-shutdown/#onshutdown","title":"onShutdown","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/","title":"Get Started","text":"<p>Congratulations on choosing Oh My Prvd! You're finally making good choices.</p> <p>Oh My Prvd is a delightful framework for next-generation Roblox game development. Here, you will learn how to build great games with Oh My Prvd, even if you're a complete newcomer to the library.</p> <p>But first, something important...</p> <p> Do not use Oh My Prvd in production unless you're really, really, really, REALLY, really willing and able to withstand large, sweeping changes. </p> <p>Yes, that was five-reallys important.</p> <p>Oh My Prvd is in very early alpha right now! You will encounter:</p> <ul> <li>nonexistent or broken features</li> <li>changes in how things work between versions</li> <li>updates that completely remove existing features</li> <li>evolving recommendations on conventions and project structure</li> </ul> <p>This is not a bad thing! It means we can quickly abandon counterproductive ideas and features, and build a solid foundation for the future.</p> <p>Don't be discouraged though, feel free to follow along with our development and try using the library in your own time. We hope you enjoy using Oh My Prvd!</p>"},{"location":"tutorials/#expectations","title":"Expectations","text":"<p>These tutorials assume:</p> <ul> <li>That you're comfortable with Roblox and the Luau scripting language.<ul> <li>These tutorials are not an introduction to Luau \u2013 If you'd like to learn,     see the Roblox creator documentation.</li> </ul> </li> <li>That - if you're using Roblox TypeScript - you're comfortable with TypeScript.<ul> <li>These tutorials are not an introduction to TypeScript - If you'd like     to learn, see Roblox TypeScript's documentation     and the TypeScript handbook</li> <li>These tutorials also assume you're familiar with Luau, which especially     is important when troubleshooting bugs \u2013 If you'd like to learn, see the     Roblox creator documentation.</li> </ul> </li> </ul> <p>Some tutorials might challenge you more than others. Remember, Oh My Prvd is built with you in mind, but it may still take a bit of time to absorb some concepts. Take your time and explore at your own pace.</p>"},{"location":"tutorials/#support","title":"Support","text":"<p>Should you be struggling to understand a concept, or need help debugging an error, here are some resources which can help.</p>"},{"location":"tutorials/#support-with-errors","title":"Support with Errors","text":"<p>Oh My Prvd attaches a link with every console log message. These links direct you to our comprehensive Error Messages documentation.</p> <pre><code>[OMP(requireAfterIgnition)]: cannot require other providers after startup\n  more info: team-fireworks.github.io/ohmyprvd/latest/reference/general/error-messages#requireafterignition\n  stack trace:\n    ohmyprvd.log:118 function throw\n    ohmyprvd.prvd:181 function use\n    Main:42\n</code></pre> <p>It explains the meaning of each message, its origin within Oh My Prvd, and relevant context. When you run into an error, that page is a great place to start!</p>"},{"location":"tutorials/#additional-support","title":"Additional Support","text":"<p>Oh My Prvd is built with you in mind and our documentation aims to be as useful and comprehensive as possible. However, you might need specific advice on an issue, perhaps you may want to learn Oh My Prvd through other means, or you caught a showstopper bug.</p> <p>Whatever you're looking for, feel free to swing by our dedicated thread over the Roblox OSS Discord server. Maintainers drop in frequently alongside eager Oh My Prvd users.</p>"},{"location":"tutorials/installation/","title":"Installation","text":"<p>Oh My Prvd is broken down into functional packages, which you will need to import into your game. This page will walk you through installing a package.</p>"},{"location":"tutorials/installation/#methods","title":"Methods","text":""},{"location":"tutorials/installation/#install-via-roblox","title":"Install via Roblox","text":"<p>If you edit directly inside Roblox Studio, then you can import a Roblox model file containing Oh My Prvd.</p> <ol> <li>Head over to Oh My Prvd's \"Releases\" page.</li> <li>Find the package you will install, if you are just following the tutorials,   you can install the <code>ohmyprvd</code> core package.</li> <li>Click the \"Assets\" dropdown to view the downloadable files:    </li> <li>Click on the package you would like to import, which should end in <code>.rbxm</code>:    </li> <li>Open Roblox Studio to import the model. If you are just following the   tutorials, just an empty baseplate will do.</li> <li>Right-click on <code>ReplicatedStorage</code>, and select \"Insert from File\":    </li> <li>You should see an <code>ohmyprvd</code> module script appear in ReplicatedStorage!</li> </ol>"},{"location":"tutorials/installation/#install-via-a-package-manager","title":"Install via a Package Manager","text":"<p>If you use Wally for Luau or NPM for TypeScript, Oh My Prvd has packages for both package managers.</p> WallyNPM <ol> <li> <p>Head over to one of these packages you will import:</p> <ul> <li><code>@znotfireman/ohmyprvd</code>     for the core package</li> <li><code>@znotfireman/ohmyprvd-lifecycles</code>     for additional lifecycle methods</li> </ul> </li> <li> <p>Copy the metadata below \"Install\", and append it below <code>[dependencies]</code> in your <code>wally.toml</code>:</p> <p></p> <p>It will look something as such, with <code>ohmyprvd</code> renamed to <code>prvd</code> for brevity:</p> <pre><code>[dependencies]\n  prvd = \"znotfireman/ohmyprvd@0.1.1-alpha\"\n</code></pre> </li> <li> <p>Then, install your packages:</p> <pre><code>$ wally install\n</code></pre> <p>This will install Oh My Prvd under the\u00a0<code>Packages</code>\u00a0directory, which is usually located in <code>ReplicatedStorage</code>:</p> <pre><code>local prvd = require(ReplicatedStorage.Packages.prvd)\n</code></pre> </li> <li> <p>If you'd want the linker modules to also export types, you can use the     Wally Package Types     tool:</p> <pre><code>$ wally-package-types --sourcemap sourcemap.json Packages/\n</code></pre> </li> </ol> <ol> <li> <p>Head over to one of these packages you will import:</p> <ul> <li><code>@rbxts/ohmyprvd</code>     for the core package</li> </ul> </li> <li> <p>Copy the command below \"Install\", and run it on a terminal:</p> <p></p> </li> <li> <p>This will install Oh My Prvd under <code>node_modules</code>, which can be imported directly:</p> <pre><code>import ohmyprvd from \"@rbxts/ohmyprvd\"\n</code></pre> </li> </ol>"},{"location":"tutorials/installation/#install-via-source","title":"Install via Source","text":"<p>If you are synchronizing external files into Roblox Studio, Oh My Prvd can be imported as source code.</p> <ol> <li>Head over to Oh My Prvd's 'Releases' page.</li> <li>Click the \"Assets\" dropdown to view the downloadable files:    </li> <li>Under \"Assets\", download <code>Source code (zip)</code>. Inside is a copy of the Oh My   Prvd GitHub repository.:    </li> <li>Inside the zip, open <code>packages</code>, then the package you'd like to import,   and copy it's <code>lib</code> folder; it may be inside another folder.</li> <li>Create a new folder inside your project named \"ohmyprvd\", place it wherever   you keep your libraries.</li> <li>For example, you might paste it inside a\u00a0<code>shared</code>\u00a0or\u00a0a <code>packages</code>\u00a0folder.</li> <li>Paste the contents of the <code>lib</code> folder into the newly created folder.</li> </ol>"},{"location":"tutorials/installation/#testing","title":"Testing","text":"<p>Now, you can create a script for testing:</p> <ol> <li>Create a <code>Script</code> under <code>ServerScriptService</code>.</li> <li> <p>Remove the following code, and paste this in depending on your installation:</p> RobloxWallyNPMDarklua <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.ohmyprvd)\n</code></pre> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n</code></pre> <pre><code>import ohmyprvd from \"@rbxts/ohmyprvd\"\n</code></pre> <pre><code>local prvd = require(\"@pkg/ohmyprvd\")\n</code></pre> </li> <li> <p>Playtest your game - if there are no errors, everything was set up correctly!</p> </li> </ol> My script didn't work! <p><pre><code>ohmyprvd is not a valid member of ReplicatedStorage \"ReplicatedStorage\"\n</code></pre> If you're seeing this error, then your script can't find Oh My Prvd.</p> <p>This code assumes you've placed Oh My Prvd under ReplicatedStorage. If you've installed both elsewhere, you'll need to the <code>require()</code>\u00a0to point towards the correct location.</p> <p>If both looks like it points to the correct location, refer back to\u00a0the previous section\u00a0and double-check you've set everything up properly. Make sure under ReplicatedStorage, there's a ModuleScript named <code>ohmyprvd</code>.</p>"},{"location":"tutorials/advanced/execution-order/","title":"Execution Order","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"tutorials/advanced/modding/","title":"Modding","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/advanced/philosophies/","title":"Philosophies","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/advanced/philosophies/#alternatives","title":"Alternatives","text":"<p>Oh My Prvd is not the first Roblox game framework. In fact, there are several existing game frameworks for Roblox. Besides Oh My Prvd, you might consider:</p> <ul> <li>Knit by sleitnick</li> <li>Flamework by fireboltofdeath</li> <li>Nevermore by Quenty</li> <li>Proton by sleitnick</li> <li>Pronghorn by Iron Stag Games</li> <li>Lazy Modules by NightLapse Studios</li> <li>Lumin Framework by Lumin Labs</li> </ul> <p>So, why did we make Oh My Prvd?</p> <p>Each of these frameworks solve the same problem in multiple angles. The goal of Oh My Prvd is to take all of the lessons and ideas learned from these projects and build a framework that can solve this problem for good. In addition, all of these frameworks have major drawbacks:</p> <ul> <li>Knit is under long term support with sparse updates and nearing an archive, in   addition it introduces a hefty level of bloat, has subpar types;</li> <li>Flamework requires TypeScript and is tightly coupled with its transformer;</li> <li>Nevermore introduces an outrageous level of bloat and also harder to use,   being geared primarily just for Quenty;</li> <li>Proton is under development and requires TypeScript;</li> <li>Pronghorn does not implement dependency injection, minimal extensibility and   introduces some bloat;</li> <li>Lazy Modules has subpar syntax, somewhat couples code;</li> <li>Lumin Framework only focuses on networking and provides no primitives for   singletons/providers;</li> </ul> <p>Finally:</p> <ul> <li>We think a framework should be distributed as a single module, for decoupling   and extensibility.</li> <li>We think a framework should be designed for both Luau and TypeScript.</li> <li>We think the conventions promoted by other frameworks (e.g. splitting between   services and controllers, forcing games to follow a structure) are   sub-optimal.</li> <li>We have a good enough understanding of the problem to develop something   robust.</li> <li>We think Oh My Prvd should be able to do more than just connect providers.</li> </ul> <p>This is not to say Oh My Prvd is superior, at least not yet:</p>"},{"location":"tutorials/advanced/snippets/","title":"VSCode Snippets","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/","title":"Components","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/attributes/","title":"Attributes","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/inheritance/","title":"Inheritance","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/components/usage/","title":"Usage","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/fundamentals/lifecycles/","title":"Lifecycle Methods","text":"<p>Oh My Prvd provides the <code>:onInit()</code> and <code>:onStart()</code> lifecycle methods. To tailor your needs, you implement custom lifecycle methods or import additional lifecycle methods.</p>"},{"location":"tutorials/fundamentals/lifecycles/#implement-your-own","title":"Implement Your Own","text":"<p>You can implement your own lifecycle method. For this example, we will create our own <code>:onPlayerAdded(player)</code> lifecycle method through the <code>Lifecycle</code> object.</p> <p>To use <code>Lifecycle</code> in your code, you first need to import it from the core package, so that you can refer to it by name:</p> LuauTypeScript <pre><code>local Lifecycle = prvd.Lifecycle\ntype Lifecycle&lt;Interface&gt; = prvd.Lifecycle&lt;Interface&gt;\n</code></pre> <pre><code>import { Lifecycle } from \"@rbxts/ohmyprvd\"\n</code></pre> <p>Let's define an interface that will sastify our lifecycle:</p> LuauTypeScript <pre><code>type OnPlayerAdded = {\n  onPlayerAdded: (self: unknown, Player) -&gt; ()\n}\n</code></pre> <pre><code>interface OnPlayerAdded {\n  onPlayerAdded(player: Player) =&gt; void\n}\n</code></pre> <p>To create a new lifecycle object, call the <code>Lifecycle</code> object and give it a method to track and a method to call when fired. It takes a parameter and a variadic; for the first part of the tutorial, this will be unnamed:</p> LuauTypeScript <pre><code>local playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", function(_, ...)\n\nend)\n</code></pre> <pre><code>const playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", (_, _) =&gt; {\n\n})\n</code></pre> <p>To fire the lifecycle, call it's <code>:fire(...)</code> method, and pass arguments to call its lifecycle method with:</p> LuauTypeScript <pre><code>Players.PlayerAdded:Connect(function(newPlayer)\n  playerAdded:fire(newPlayer)\nend)\nfor _, existingPlayer in ipairs(Players:GetPlayers()) do\n  playerAdded:fire(existingPlayer)\nend\n</code></pre> <pre><code>Players.PlayerAdded.Connect((newPlayer) =&gt; {\n  playerAdded.fire(newPlayer)\n})\nfor (const existingPlayer of Players:GetPlayers()) {\n  playerAdded.fire(existingPlayer)\n}\n</code></pre> <p>Under the hood, Oh My Prvd will register all providers that specify an <code>onPlayerAdded</code> method.</p>"},{"location":"tutorials/fundamentals/lifecycles/#firing-the-lifecycle","title":"Firing The Lifecycle","text":"<p>Our lifecycle does nothing when we fire it. The lifecycle constructor passes itself as the first argument, to which you can access it's listeners:</p> LuauTypeScript <pre><code>local playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", function(self, ...)\n  for _, listener in ipairs(self.listeners) do\n    task.spawn(listener.onPlayerAdded, listener)\n  end\nend)\n</code></pre> <pre><code>const playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", (lifecycle, _) =&gt; {\n  for (const listener of lifecycle.listeners) {\n    task.spawn(() -&gt; listener.onPlayerAdded)\n  }\n})\n</code></pre> <p>The variadic argument are the arguments passed when the lifecycle is fired. Try asking for a <code>player</code> argument for this handler:</p> LuauTypeScript <pre><code>local playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", function(self, player)\n  for _, listener in ipairs(self.listeners) do\n    task.spawn(listener.onPlayerAdded, listener, player)\n  end\nend)\n</code></pre> <pre><code>const playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", (lifecycle, ...args) =&gt; {\n  for (const listener of lifecycle.listeners) {\n    task.spawn(() -&gt; listener.onPlayerAdded(args[0]))\n  }\n})\n</code></pre> <p>Now, when a player joins the game, the lifecycle fires its listeners:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal MyProvider = {}\nfunction MyProvider:onPlayerAdded(player)\n  print(\"Greetings\", player)\nend\n\nreturn prvd.new(\"MyProvider\", MyProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\nexport const MyProvider = Provider(\"MyProvider\", {\n  onPlayerAdded(player) {\n    print(\"Greetings\", player)\n  }\n})\n</code></pre> <p>The PointsProvider from earlier can be rewritten to use it:</p> LuauTypeScript <pre><code>-- ...\n\nfunction PointsProvider.onStart(self: Self)\n  Players.PlayerRemoving:Connect(function(player)\n    self.points[player] = nil\n  end)\nend\n\nfunction PointsProvider.onPlayerAdded(self: Self, newPlayer: Player)\n  self:setDefaultPoints(newPlayer)\nend\n\n-- ...\n</code></pre> <pre><code>export const PointsProvider = Provider(\"PointsProvider\", {\n  // ...\n  onStart() {\n    Players.PlayerRemoving.Connect((player) =&gt; {\n      this.points.delete(player)\n    })\n  }\n\n  onPlayerAdded(newPlayer: Player) {\n    this.setDefaultPoints(newPlayer)\n  }\n  // ...\n})\n</code></pre>"},{"location":"tutorials/fundamentals/lifecycles/#preset-handlers","title":"Preset Handlers","text":"<p>For convenience, Oh My Prvd exports two handlers you can use while constructing lifecycles.</p> <p>For lifecycles that do not depend on execution order, you can pass <code>fireConcurrent</code> as the <code>fire</code> method. This will spawn all of the lifecycle listeners as threads:</p> LuauTypeScript <pre><code>local fireConcurrent = prvd.fireConcurrent\nlocal playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", fireConcurrent)\n</code></pre> <pre><code>import { Lifecycle, fireConcurrent } from \"@rbxts/ohmyprvd\"\nconst playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", fireConcurrent)\n</code></pre> <p>Contrast to <code>fireConcurrent</code>, for lifecycles that do depend on execution order, you can pass <code>fireSequential</code> as the <code>fire</code> method. This will run all of the lifecycle listeners synchronously:</p> LuauTypeScript <pre><code>local fireSequential = prvd.fireSequential\nlocal playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", fireSequential)\n</code></pre> <pre><code>import { Lifecycle, fireSequential } from \"@rbxts/ohmyprvd\"\nconst playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", fireSequential)\n</code></pre> <p>Exercise error safety</p> <p><code>fireSequential</code> does not protect itself from errors. If a listener throws an error in its lifecycle method, it will halt further execution.</p> <p>Instead, write a handler that is protected from errors:</p> LuauTypeScript <pre><code>local playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", function(self, player)\n  for _, listener in ipairs(self.listeners) do\n    local ok, result = pcall(listener.onPlayerAdded, listener, player)\n    if ok == false then\n      warn(listener, \"threw an error!\", result)\n    end\n  end\nend)\n</code></pre> <pre><code>const playerAdded: Lifecycle&lt;OnPlayerAdded&gt; = Lifecycle(\"onPlayerAdded\", (lifecycle, player) =&gt; {\n  for (const listener of lifecycle.listeners) {\n    const [ok, result] = pcall(() =&gt; listener.onPlayerAdded(player))\n    if (ok == false) {\n      warn(listener, \"threw an error!\", result)\n    }\n  }\n})\n</code></pre>"},{"location":"tutorials/fundamentals/lifecycles/#additional-lifecycles","title":"Additional Lifecycles","text":"<p>Creating additional lifecycle methods such as <code>:onPlayerAdded(player)</code> can be a hassle. For this, Oh My Prvd exports additional lifecycle methods through a separate <code>ohmyprvd-lifecycles</code> package, which you will have to install.</p> <p>Once installed, import the package, preferably within your startup script:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nrequire(ReplicatedStorage.Packages.ohmyprvdLifecycles)\n</code></pre> <pre><code>import \"@rbxts/ohmyprvd-lifecycles\"\n</code></pre> <p>This package exports nothing. Instead, it registers a separate provider that implements a host of lifecycle events during runtime:</p> <ul> <li><code>:onPostSimulation(dt)</code>, <code>:onPreSimulation(dt)</code>, and <code>:onPreRender(dt)</code> lets you   hook onto RunService's runtime events:<ul> <li><code>:onPostSimulation(dt)</code> runs every <code>RunService.PostSimulation</code> and is     optimal for responding to changes in the physics state.</li> <li><code>:onPreSimulation(dt)</code> runs every <code>RunService.PreSimulation</code> and is     optimal for manipulating physics.</li> <li><code>:onPreRender(dt)</code> runs every <code>RunService.PreRender</code>. Notably, this only     runs on the client.</li> </ul> </li> <li><code>:onShutdown</code> hooks onto <code>game:BindToClose</code>, or <code>plugin.Unloading</code> if ran   under a plugin environment. <code>:onShutdown</code> also cleanups built-in lifecycle   methods, preventing memory leaks especially for a plugin. It's great for doing   post-mortem cleanup once the game closes or your plugin is unloaded.</li> <li><code>:onPlayerAdded(player)</code> and <code>:onPlayerRemoving(player)</code> binds to   Players.PlayerAdded and Players.PlayerRemoving respectively, making it ideal   for tracking players.</li> </ul>"},{"location":"tutorials/fundamentals/providers/","title":"Providers","text":"<p>Oh My Prvd allows you to define providers for your game logic. These provide specific functions within your game, e.g. you might create a <code>SaveDataProvider</code> to manage save files or a <code>CameraProvider</code> to handle player camera movement.</p>"},{"location":"tutorials/fundamentals/providers/#structure","title":"Structure","text":"<p>This is the minimum structure of a provider, which can be used and hook onto lifecycle events:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\n\nexport = Provider(\"PointsProvider\", {})\n</code></pre> Too verbose? <p>If writing <code>prvd.Provider</code> sounds verbose for you, Oh My Prvd aliases the <code>Provider</code> constructor with <code>.new</code>.</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nreturn prvd.new(\"PointsProvider\", PointsProvider)\n</code></pre> <p>For consistency, we recommend using <code>Provider</code> when favorable.</p> <p>The <code>name</code> argument signifies what to identify your provider as. This name must be unique from all other providers. Ideally, you should name your variable the same as the service name, e.g. <code>local PointsProvider</code> would mean <code>prvd.new(\"PointsProvider\", ...)</code>.</p> <p>Notice that you're creating the provider at the bottom of a file, and then returning it. This lets Oh My Prvd to strictly type your provider, something which will be important later.</p>"},{"location":"tutorials/fundamentals/providers/#methods-properties-the-likes","title":"Methods, Properties, The Likes","text":"<p>Providers are just tables at the end of the day. As such, it's easy to add methods, properties, and the likes to providers.</p> <p>Let's add a <code>points</code> property to our <code>PointsProvider</code>, which will be a map of a <code>Player</code> and their points:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nPointsProvider.points = {}\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\n\nexport = Provider(\"PointsProvider\", {\n  points: Map&lt;Player, number&gt; = {}\n})\n</code></pre> <p>To instantiate our <code>points</code>, let's also implement a <code>setDefaultPoints</code> method for convenience:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider),\n  player: Player\n)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\n\nexport = Provider(\"PointsProvider\", {\n  points: Map&lt;Player, number&gt; = {}\n\n  setDefaultPoints(player: Player) {\n    this.points.get(player)?.set(10)\n  }\n})\n</code></pre> <p>Take a step back, and review what we wrote.</p> <p>Notice in our <code>setDefaultPoints</code>, we require the first argument to be <code>self</code>, which is <code>typeof</code> our <code>PointsProvider</code>.</p> <p>This allows Luau to provide useful type information. Notice how if we omit the <code>self</code> argument and use a colon <code>:</code> for our method, we lose typings for <code>self</code>:</p> <pre><code>function PointsProvider:setDefaultPoints(\n  player: Player\n)\n  -- self.points is typed as `a`, which is not very helpful!\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n</code></pre> <p>Contrast as to if we typed <code>self</code> as a parameter:</p> <pre><code>function PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider),\n  player: Player\n)\n  -- self.points is helpfully typed as `{| [Player]: number |}`!\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n</code></pre> <p><code>typeof(PointsProvider)</code> is not very concise. Let's make a type alias, appropriately named <code>Self</code>:</p> <pre><code>-- use just typeof()...\ntype Self = typeof(PointsProvider)\n-- ...or wrap it inside prvd.Provider\ntype Self = prvd.Provider&lt;typeof(PointsProvider)&gt;\n</code></pre> <p>Both types are good, pick your poison and run with it.</p> <p>We could then easily type <code>self</code> as such:</p> <pre><code>function PointsProvider.setDefaultPoints(\n  self: Self,\n  player: Player\n)\n</code></pre> <p>Now, our code can use <code>self</code> as a shorthand for the <code>PointsProvider</code>, while other snippets of code could use our method through one of the following:</p> <pre><code>-- pass self directly as an argument...\nPointsProvider.setDefaultPoints(PointsProvider, player)\n-- ...or let Luau pass self for us!\nPointsProvider:setDefaultPoints(player)\n</code></pre>"},{"location":"tutorials/fundamentals/providers/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>Providers and the likes can implement lifecycle methods, by having a method that matches its lifecycle name.</p> <p>Oh My Prvd provides two lifecycle events out of the box:</p> <ul> <li><code>:onInit()</code> runs sequentially before any other lifecycle methods, methods are   expected to be infallible and preferably non-yielding.<ul> <li>If you return a promise, Oh My Prvd will wait for the promise to resolve.       Anything with an <code>:andThen</code> method and an <code>:awaitStatus</code> method will be       picked up by Oh My Prvd.</li> </ul> </li> <li>In contrast, <code>:onStart()</code> runs concurrently after all other lifecycle   methods have been registered. This means failures and yields do not affect   other providers.</li> </ul> <p>Let's implement the <code>:onStart()</code> lifecycle, where we will set default points for every player that joins:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\ntype Self = typeof(PointsProvider)\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(\n  self: Self,\n  player: Player\n)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nfunction PointsProvider.onStart(\n  self: Self\n)\n  Players.PlayerAdded:Connect(function(newPlayer)\n    self:setDefaultPoints(newPlayer)\n  end)\n  for _, existingPlayer in pairs(Players:GetPlayers()) do\n    self:setDefaultPoints(existingPlayer)\n  end\nend\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\nimport { Players } from \"@rbxts/services\"\n\nexport = Provider(\"PointsProvider\", {\n  points: Map&lt;Player, number&gt; = {},\n\n  setDefaultPoints(player: Player) {\n    this.points.get(player)?.set(10)\n  }\n\n  start() {\n    Players.PlayerAdded.Connect((newPlayer) =&gt; {\n      this.setDefaultPoints(newPlayer)\n    })\n    for (const existingPlayer in Players.GetPlayers()) {\n      this.setDefaultPoints(existingPlayer)\n    }\n  }\n})\n</code></pre>"},{"location":"tutorials/fundamentals/providers/#memory","title":"Memory","text":"<p>Now we have a problem: theres a memory leak.</p> <p>When we set points for a player, we add the player to the table. What happens when the player leaves? Nothing. Which is an issue.</p> <p>That player's data is forever held onto within the <code>points</code> table. We need to clear out that data when the player leaves. Let's hook up our <code>:start</code> method with the <code>Players.PlayerRemoving</code> event and remove their points:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\nlocal Players = game:GetService(\"Players\")\n\nlocal PointsProvider = {}\nPointsProvider.points = {}\n\nfunction PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider),\n  player: Player\n)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nfunction PointsProvider.start(\n  self: typeof(PointsProvider)\n)\n  Players.PlayerAdded:Connect(function(newPlayer)\n    self:setDefaultPoints(newPlayer)\n  end)\n  for _, existingPlayer in pairs(Players:GetPlayers()) do\n    self:setDefaultPoints(existingPlayer)\n  end\n  Players.PlayerRemoving:Connect(function(player)\n    self.points[player] = nil\n  end)\nend\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre>"},{"location":"tutorials/fundamentals/providers/#dependencies","title":"Dependencies","text":"<p>Often, providers may depend on other providers, such as a <code>CombatProvider</code> requiring the player's <code>CharacterProvider</code>. Oh my Prvd lets you use providers through dependency injection.</p> <p>First, create a file for a new <code>MathProvider</code> with the following:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal MathProvider = {}\n\nfunction MathProvider.add(\n  self: typeof(MathProvider),\n  a: number,\n  b: number\n): number\n  -- this method is very expensive!\n  task.wait(5)\n  return a + b\nend\n\nreturn prvd.Provider(\"MathProvider\", MathProvider)\n</code></pre> <pre><code>import { Provider } from \"@rbxts/ohmyprvd\"\n\nexport = Provider(\"MathProvider\", {\n  add(a: number, b: number) {\n    // this method is very expensive!\n    task.wait(5)\n    return a + b\n  }\n})\n</code></pre> <p>Then, from <code>PointsProvider</code>, import your newly created <code>MathProvider</code>:</p> <pre><code>local MathProvider = require(script.Parent.MathProvider)\n</code></pre> <p>Finally, just specify your provider <code>use()</code>s another provider:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal MathProvider = require(script.Parent.MathProvider)\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nlocal PointsProvider = {}\nPointsProvider.points = {}\nPointsProvider.mathProvider = prvd.use(MathProvider)\n\nfunction PointsProvider.setDefaultPoints(\n  self: typeof(PointsProvider),\n  player: Player\n)\n  if self.points[player] ~= nil then\n    return\n  end\n  self.points[player] = 10\nend\n\nfunction PointsProvider.start(\n  self: typeof(PointsProvider)\n)\n  Players.PlayerAdded:Connect(function(newPlayer)\n    self:setDefaultPoints(newPlayer)\n  end)\n  for _, existingPlayer in pairs(Players:GetPlayers()) do\n    self:setDefaultPoints(existingPlayer)\n  end\n  Players.PlayerRemoving:Connect(function(player)\n    self.points[player] = nil\n  end)\nend\n\nfunction PointsProvider.addPoints(\n  self: typeof(PointsProvider),\n  player: Player,\n  points: number\n)\n  self.points[player] = self.mathProvider:add(\n    self.points[player],\n    points\n  )\nend\n\nreturn prvd.Provider(\"PointsProvider\", PointsProvider)\n</code></pre> Do not use dependencies outside of lifecycle methods! <p>Oh My Prvd only returns a shadow of the <code>use()</code>d provider. You cannot use it outside of lifecycle methods.</p> <p>Behind the scenes, Oh My Prvd will keep track of what dependencies your provider uses, figure out the correct load order for you, and inject your dependencies.</p> <p>This is also why you can't freeze your provider tables - Oh My Prvd will have to modify them.</p>"},{"location":"tutorials/fundamentals/providers/#congratulations","title":"Congratulations","text":"<p>You just successfully wrote your first provider using Oh My Prvd!</p> <p>That was a taste of Oh My Prvd. Later on, you will learn how to register your own lifecycle methods, use Oh My Prvd networking primitives, and creating your own components.</p> <p>You can find the completed modules for MathProvider and PointsProvider in the <code>examples</code> directory.</p> <p>Once you're comfortable writing providers, you are ready to take on the rest of what Oh My Prvd offers.</p>"},{"location":"tutorials/fundamentals/startup/","title":"Startup","text":"<p>With your providers defined, its time to start Oh My Prvd.</p>"},{"location":"tutorials/fundamentals/startup/#preloading","title":"Preloading","text":"<p>It's necessary to preload your providers to for Oh My Prvd to pick it up. For convenience, you can use the <code>prvd.preload(instances, predicate)</code> function, which will load all modules given an array of instances:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nprvd.preload(script.Providers:GetChildren())\n</code></pre> <pre><code>import { preload } from \"@rbxts/ohmyprvd\"\npreload(script.Providers.GetChildren())\n</code></pre> <p>You can also pass a predicate function to filter the target modules:</p> LuauTypeScript <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal prvd = require(ReplicatedStorage.Packages.ohmyprvd)\n\nprvd.preload(\n  script.Providers.GetChildren(),\n  function(module: ModuleScript)\n    return module.Name:find(\"Provider$\") ~= nil\n  end\n)\n</code></pre> <pre><code>import { preload } from \"@rbxts/ohmyprvd\"\npreload(\n  script.Providers.GetChildren(),\n  (module) =&gt; module.Name.find(\"Provider$\") !== undefined\n)\n</code></pre>"},{"location":"tutorials/fundamentals/startup/#startup_1","title":"Startup","text":"<p>Finally, start Oh My Prvd, and you're off to the races:</p> <pre><code>prvd.start()\n</code></pre> <p>If another script requires Oh My Prvd to be ignited, <code>awaitStart()</code> can be used, which will yield until Oh My Prvd is fully ignited:</p> <pre><code>prvd.awaitStart()\n</code></pre> <p>Alternatively, if you need to bind to startup, <code>onStart(callback)</code> can be used, which will spawn the callback when Oh My Prvd has fully ignited:</p> LuauTypeScript <pre><code>prvd.onStart(function()\n  print(\"ignited!\")\nend)\n</code></pre> <pre><code>onStart(() =&gt; {\n  print(\"ignited!\")\n})\n</code></pre>"},{"location":"tutorials/net/","title":"Net","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/events/","title":"Events","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/functions/","title":"Functions","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/middlewares/","title":"Middlewares","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/net/namespaces/","title":"Namespaces","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"}]}